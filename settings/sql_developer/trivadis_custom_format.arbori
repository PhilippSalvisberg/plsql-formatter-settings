/*
 * Copyright 2021 Philipp Salvisberg <philipp.salvisberg@trivadis.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Lightweight Formatter for SQL Developer and SQLcl
 * The idea is to keep the code formatted "as is" and apply chosen formatting rules only.
 */

-- ====================================================================================================================
-- Phase - Initialization and pre-processing.
-- ====================================================================================================================

-- Standard functionality such as "runOnce"
include "std.arbori"

-- Callback function to ensure numeric literals are formatted correctly (without whitespaces)
dontFormatNode:
    [node) numeric_literal
->
;

-- ":indentCondtions" must be used, otherwise the Arbori program will be considered invalid and the default is used.
-- This rule is never call, hence it does not matter what node is selected.
-- However, I chose to use "identifier" to avoid an Arbori warning.
dummy:
  :indentConditions & [node) identifier
;

-- "skipWhitespaceBeforeNode" must be defined, otherwise the Arbori program will be considered invalid and the default is used.
-- The rule is executed by the serializer, hence it selected node matters.
-- The node "'dummy_node_skip_ws_before'" does not exist and throws a "Symbol ''dummy_node_skip_ws_before'' not found" warning.
-- This warning is shown in the log or on the console and can be ignored. The normal SQLDev user will be not aware of this warning.
skipWhiteSpaceBeforeNode:
  [node) 'dummy_node_skip_ws_before'
->
;

-- analytic functions, to be treated as keywords
"analytics":
      [identifier) identifier
    & [call) analytic_function
    & [call = [identifier
;

-- all identifiers
"ids":
    [identifier) identifier
;

-- Callback function to reduce the list of keywords by the identifiers provided here
identifiers:
    "ids" - "analytics"
->
;

-- Global variables, which are likely to be used in more than one Arbori query/action
defineGlobalVariables:
    runOnce
-> {
    // Java classes
    var Format = Java.type('oracle.dbtools.app.Format');
    var HashMap = Java.type('java.util.HashMap');
    var HashSet = Java.type('java.util.HashSet');
    var Integer = Java.type('java.lang.Integer');
    var LexerToken = Java.type('oracle.dbtools.parser.LexerToken');
    var Substitutions = Java.type('oracle.dbtools.parser.Substitutions');
    var System = Java.type('java.lang.System');
    var Token = Java.type('oracle.dbtools.parser.Token');

    // use reflection to access hidden field newlinePositions
    var newlinePositionsField = Format.class.getDeclaredField("newlinePositions");
    newlinePositionsField.setAccessible(true);
    var newlinePositions = newlinePositionsField.get(struct);

    // get the configured number of spaces for a single indentation from the configuration
    var indentSpaces = struct.options.get("identSpaces");
    var maxCharLineSize = struct.options.get("maxCharLineSize");

    // lexer tokens including hidden tokens (LINE_COMMENT, COMMENT, WS, MACRO_SKIP, SQLPLUSLINECONTINUE_SKIP)
    // are relevant to find comments between tokens. These variables are populated in
    // keepSignificantWhitespaceBeforeLeafNodes
    var tokens = null;
    var mapParserPosToLexerPos = new HashMap();
}

-- Global functions, which are likely to be used in more than one Arbory action
defineGlobalFunctions:
    runOnce
-> {
    /* return a string with the requested number of spaces */
    function getSpaces(count) {
        var result = "";
        for (var i=0; i<count; i++) {
            result += " ";
        }
        return result;
    }

    /* return the indentation at a node position, converts the default null to a single space */
    function getIndent(pos) {
        var indent = newlinePositions.get(new Integer(pos));
        if (indent == null) {
            return " ";
        }
        return indent;
    }

    /* returns the indentation without leading new lines from a string */
    function numCharsAfterNewLine(indent) {
        if (indent.contains("\n")) {
            return indent.length() - indent.lastIndexOf("\n") - 1;
        }
        return indent.length();
    }

    /* returns the leading new lines from a node (without trailing spaces) */
    function leadingNewLinesOfNode(node) {
        var startPos=node.from;
        var indent = getIndent(startPos);
        if (indent.contains("\n")) {
            return indent.substring(0, indent.lastIndexOf("\n") + 1);
        }
        return "";
    }

    /* returns the column of a node, considers all preceding nodes */
    function columnOfNode(nodeFrom) {
        var startPos=nodeFrom;
        var col=numCharsAfterNewLine(getIndent(startPos));
        var indent = getIndent(startPos);
        for (var i=startPos-1; i>=0 && !indent.contains("\n"); i=i-1) {
            col += target.getSrc().get(i).content.length();
            var indent = getIndent(i);
            col += numCharsAfterNewLine(indent);
        }
        return col;
    }

    /* returns true if a node or one of its children contains an indentation with a new line character */
    function containsLineBreak(node) {
        for (var i = node.from; i < node.to; i++) {
            var value = getIndent(i);
            if (value.contains("\n")) {
                return true;
            }
        }
    }

    /* returns true if single-line or multi-line comments exists between two node positions */
    function hasCommentsBetweenPos(startPos, endPos) {
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                return true;
            }
        }
        return false;
    }

    /* returns the the last comment (sl or ml) between two node positions */
    function getLastCommentBetweenPos(startPos, endPos) {
        var comment = "";
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                comment = tokens[i].content;
            }
        }
        return comment;
    }

}

-- Replace multiple, consecutive empty lines with one empty line.
-- This code changes the input (target.input) and the lexer tokens (target.src).
-- Therefore this code must run at the beginning of the Arbori program.
max_one_empty_line: runOnce -> {
    var offOnRanges = [];

    var populateOffOnRanges = function(tokens) {
        var off = -1;
        offOnRanges = [];
        for (var i in tokens) {
            if (tokens[i].type == Token.LINE_COMMENT || tokens[i].type == Token.COMMENT) {
                if (tokens[i].content.toLowerCase().contains("@formatter:off") || tokens[i].content.toLowerCase().contains("noformat start")) {
                    off = tokens[i].begin;
                }
                if (off != -1) {
                    if (tokens[i].content.toLowerCase().contains("@formatter:on") || tokens[i].content.toLowerCase().contains("noformat end")) {
                        offOnRanges.push([off, tokens[i].end]);
                        off = -1;
                    }
                }
            }
        }
    }

    var inOffOnRange = function(pos) {
        for (var x in offOnRanges) {
            if (pos >= offOnRanges[x][0] && pos < offOnRanges[x][1]) {
                return true;
            }
        }
        return false;
    }

    var removeDuplicateEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var firstEOLToken = 0;
        var secondEOLToken = 0;
        var lastEOLToken = 0;
        for (i = 0; i < tokens.length; i++) {
            if (tokens[i].type == Token.LINE_COMMENT && firstEOLToken == 0) {
                firstEOLToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (firstEOLToken == 0) {
                    firstEOLToken = tokens[i];
                } else if (secondEOLToken == 0) {
                    secondEOLToken = tokens[i];
                } else {
                    lastEOLToken = tokens[i];
                }
                continue;
            }
            if (tokens[i].type != Token.WS) {
                if (lastEOLToken != 0) {
                    if (!inOffOnRange(secondEOLToken.begin)) {
                        substitutions.put(secondEOLToken.begin,lastEOLToken.begin,"");
                    }
                }
                firstEOLToken = 0;
                secondEOLToken = 0;
                lastEOLToken = 0;
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    var removeWSOnEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var eolToken = 0
        for (i = 0; i < tokens.length; i++) {
            if (tokens[i].type != Token.WS) {
                eolToken = 0;
                continue;
            }
            if (eolToken == 0 && (tokens[i].type == Token.LINE_COMMENT || tokens[i].content == "\n")) {
                eolToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (eolToken != 0) {
                    if (!inOffOnRange(eolToken.end)) {
                        substitutions.put(eolToken.end,tokens[i].begin,"");
                    }
                }
                eolToken = tokens[i];
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    // replacements
    removeDuplicateEmptyLines();
    removeWSOnEmptyLines();

    // tokens without WS and comments (mimicking default behaviour)
    var Lexer = Java.type('oracle.dbtools.parser.Lexer');
    var defaultTokens = Lexer.parse(target.input);

    // produce a new parse tree based on the updated lexer tokens
    var Parsed = Java.type('oracle.dbtools.parser.Parsed');
    var SqlEarley = Java.type('oracle.dbtools.parser.plsql.SqlEarley')
    var newTarget = new Parsed(target.input, defaultTokens, SqlEarley.getInstance(), Java.to(["sql_statements"], "java.lang.String[]"));

    // update token list based on fixed source code (without WS tokens)
    target.src.clear();
    target.src.addAll(newTarget.src);

    // enable next line to print all node names on the console (e.g. when SQLDev UI shows unnamed nodes)
    // target.root.printTree();
}

-- add explicit whitespace before each leaf node, if the whitespace before is not a single space (default)
keep_significant_whitespace_before_leaf_nodes:
    runOnce
-> {
    tokens = LexerToken.parse(target.input, true);  // include hidden tokens not relevant to build a parse tree
    var hiddenTokenCount = 0;
    var wsBefore = "";
    for (var i in tokens) {
        var type = tokens[i].type;
        // count hidden tokens
        if (type == Token.LINE_COMMENT || type == Token.COMMENT || type == Token.WS ||
            type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP)
        {
            hiddenTokenCount++;
            // concatenate whitespace before a node
            if (type == Token.WS) {
                wsBefore += tokens[i].content;
            } else {
                // ensure that other hidden token are not counted as whitespace
                wsBefore = "";
            }
        } else {
            mapParserPosToLexerPos.put(new Integer(i-hiddenTokenCount), i);
            if (wsBefore != " ") {
                // add collected whitespace before leaf node (actually at the position of the leaf node)
                // add also empty strings to ensure that not a space is added between tokens
                struct.putNewline(i-hiddenTokenCount, wsBefore);
                logger.fine(struct.getClass(), "keepSignificantWhitespaceBeforeLeafNodes: add "
                    + wsBefore.length() + " whitespace before node at position " + (i-hiddenTokenCount));
            }
            wsBefore = "";
        }
    }
}

-- ====================================================================================================================
-- Phase 2 - Processing rule by rule.
-- ====================================================================================================================

-- --------------------------------------------------------------------------------------------------------------------
-- A-1: Do not use tabs.
-- --------------------------------------------------------------------------------------------------------------------

-- replace tabs with the configured indentation (default is 3)
a1_replace_tabs_with_spaces:
    runOnce
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\t")) {
            struct.putNewline(key, value.replaceAll("\t", indent));
            logger.fine(struct.getClass(), "a1_replace_tabs_with_spaces: replaced tabs with spaces at position " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A-2: Remove trailing spaces.
-- --------------------------------------------------------------------------------------------------------------------

a2_remove_trailing_spaces:
    runOnce
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        // handle Linux and Windows line separators regardless of the OS
        var newValue = value.replaceAll("[ ]+\\n", "\n").replaceAll("[ ]+\\r\\n", "\r\n");
        if (!value.equals(newValue)) {
            struct.putNewline(key, newValue);
            logger.fine(struct.getClass(), "a2_remove_trailing_spaces: removed trailings spaces at position " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A-3: Do not format code between @formatter:off and @formatter:on comments.
-- --------------------------------------------------------------------------------------------------------------------

a3_dont_format_off_on_ranges:
    runOnce
-> {
    var hiddenTokenCount = 0;
    var format = true;
    for (var i in tokens) {
        var type = tokens[i].type;
        if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
            var content = tokens[i].content.toLowerCase();
            if (content.contains("@formatter:off") || content.contains("noformat start")) {
                format = false;
            }
            if (content.contains("@formatter:on") || content.contains("noformat end")) {
                format = true;
            }
            hiddenTokenCount++;
        } else if (type == Token.WS || type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP) {
            hiddenTokenCount++
        } else {
            /* expected types: QUOTED_STRING, DQUOTED_STRING, BQUOTED_STRING, DIGITS, OPERATION, IDENTIFIER, AUXILIARY, INCOMPLETE */
            if (!format) {
                var pos = new Integer(i-hiddenTokenCount);
                struct.unformattedPositions.add(pos);
                logger.fine(struct.getClass(), "a3_dont_format_off_on_ranges: do not format node at position " + pos);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R-3: One command per line.
-- R-4: Keywords "loop", "else", "elsif", "end", "when" on a new line.
-- --------------------------------------------------------------------------------------------------------------------

r3_stmt_in_first_conditional_compilation_branch:
    runOnce
-> {
    var posInConditionalBranch = new HashSet();
    var pos = 0;
    var withinFirstBranch = false;
    for (i = 0; i < tokens.length; i++) {
        var type = tokens[i].type
        var content = tokens[i].content.toLowerCase()
        if (type == Token.MACRO_SKIP && content.startsWith("$if ")) {
            withinFirstBranch = true;
            continue;
        }
        if (withinFirstBranch && type == Token.MACRO_SKIP && content.startsWith("$")) {
            withinFirstBranch = false;
            continue;
        }
        if (type != Token.WS && type != Token.MACRO_SKIP && type != Token.COMMENT && type != Token.LINE_COMMENT) {
            if (withinFirstBranch) {
                posInConditionalBranch.add(new Integer(pos));
                logger.fine(struct.getClass(), "r3_stmt_in_first_conditional_compilation_branch: ignore node at position " + pos);
            }
            pos++;
        }
    }
}

r3_sqlplus_commands:
    [node) sqlplus_command
;

r3_sql_commands:
    [node) sql_statement
;

r3_plsql_commands:
      [node) subprg_spec
          & ![node^^) create            -- standalone function/procedure
          & ![node-1) member_or_static  -- object type spec
          & ![node^-1) member_or_static -- object type body
          & ![node-1) 'CONSTRUCTOR'     -- object type spec
          & ![node^-1) 'CONSTRUCTOR'    -- object type body
    | [node) basic_decl_item
    | [node) stmt
;

r3_plsql_keywords:
      [node) 'LOOP' & ![node-1) 'END'
    | [node) 'WHEN'
          & ![node^^) exit_stmt
          & ![node^) merge_insert_clause
          & ![node^) merge_update_clause
    | [node) 'BEGIN'
    | [node) 'END'
    | [node) 'ELSIF'
    | [node) 'ELSE'
;

r3_case_expressions:
      [parent) case_expression
    & ([node) 'WHEN' | [node) 'ELSE' | [node) 'END')
    & parent < node
;

r3_commands:
      r3_sqlplus_commands
    | r3_sql_commands
    | r3_plsql_commands
    | (r3_plsql_keywords - r3_case_expressions)
-> {
    var node = tuple.get("node");
    if (!posInConditionalBranch.contains(node.from)) {
        var indent = getIndent(node.from);
        if (!indent.contains("\n")) {
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "r3_commands: added line break at position " + node.from);
        } else {
            /* remove existing indentation, enforce conformity in these cases */
            var indent = newlinePositions.get(node.from);
            var newIndent = indent.substring(0, indent.lastIndexOf("\n")+1);
            struct.putNewline(node.from, newIndent);
            logger.fine(struct.getClass(), "r3_commands: removed indentation at position " + node.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R-5: Commas in front of separated elements.
-- --------------------------------------------------------------------------------------------------------------------

-- Considers the following SQLDev settings:
-- - Line Breaks On Comma
--     "Before" enforces a line break before the comma (this is rule 5)
--     "After" enforces line break after the comma
--     "No Breaks" keeps line breaks before/after comma "as is"
-- - White Space After Commas (option for lines starting with a comma)
--     "checked" enforces exactly one space after the comma
--     "unchecked" enforces no space after a comma

r5_get_prefs:
    runOnce
-> {
    /* boolean true=space, false=no space */
    var spaceAfterCommas = struct.options.get("spaceAfterCommas");

    function getIndentAfterComma(indent) {
        var plus = 1;
        if (spaceAfterCommas) {
           plus++;
        }
        return indent + getSpaces(plus);
    }

    function getIndentForComma(indent) {
        var len = indent.length() - 1;
        if (spaceAfterCommas) {
           len = len - 1;
        }
        return indent.substring(0, len);
    }


    function removeLeadingSpaces(nodeFrom) {
        var indent = getIndent(nodeFrom);
        if (indent.contains("\n")) {
            var pos = 0;
            for (var i=0; i<indent.length(); i++) {
                if (indent.substring(i, i+1) == " ") {
                    pos++;
                } else {
                    break;
                }
            }
            struct.putNewline(nodeFrom, indent.substring(pos));
        } else {
            struct.putNewline(nodeFrom, "");
        }
    }
}

r5_commas:
    [node) ','
-> {
    var commaNode = tuple.get("node");
    var prevPos = commaNode.from-1;
    var nextPos = commaNode.to;
    if (struct.breaksAfterComma()) {
        var indentCommaNode = getIndent(commaNode.from);
        if (indentCommaNode.contains("\n") && !hasCommentsBetweenPos(prevPos, commaNode.to)) {
            /* situation: a new line was added before the comma instead of after */
            struct.putNewline(commaNode.to, getIndentAfterComma(indentCommaNode));
            logger.fine(struct.getClass(), "r5_commas: fixed indent after comma at " + commaNode.to);
            struct.putNewline(commaNode.from, "");
        }
    }
    if (struct.breaksBeforeComma()) {
        var indentCommaNode = getIndent(commaNode.from);
        if (!indentCommaNode.contains("\n")) {
            var indentNextNode = getIndent(nextPos);
            if (indentNextNode.contains("\n")) {
                /* situation: a new line was added after the comma instead of before */
                struct.putNewline(commaNode.from, getIndentForComma(indentNextNode));
                logger.fine(struct.getClass(), "r5_commas: fixed indent before comma at " + commaNode.from);
                if (!hasCommentsBetweenPos(commaNode.from-1, commaNode.to)) {
                    /* remove all whitespace for node */
                    struct.putNewline(nextPos, "");
                } else {
                    var comment = getLastCommentBetweenPos(commaNode.from-1, commaNode.to);
                    if (comment.startsWith("--")) {
                       /* we must not remove the newline after a single-line comment */
                    } else {
                       /* removing newline after multi-line comment is wanted, but does not work in SQLDev 20.4.1, it would remove indentation only but keep the newline */
                       logger.fine(struct.getClass(), "r5_commas: SQLDev 20.4.1 bug: new line after a multi-line-comment cannot be set at " + commaNode.from);
                    }
                }
            }
        }
    }
    /* always handle space after comma */
    removeLeadingSpaces(nextPos);
    if (spaceAfterCommas) {
        var indent = getIndent(nextPos);
        if (!indent.contains("\n")) {
            struct.putNewline(nextPos, " " + indent);
        }
    } else {
        var indentCommaNode = getIndent(commaNode.from);
        var indentNextNode = getIndent(nextPos);
        if (!indentCommaNode.contains("\n") && !indentNextNode.contains("\n")) {
            struct.putNewline(nextPos, " ");
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R-2: 3 space indention.
-- --------------------------------------------------------------------------------------------------------------------

-- Determine the level for each position managed in newlinePositions with a newline char ("\n") and then
-- ensure that the indentation is >= the level*indentSpaces, if not add missing spaces.
-- This code must be executed after missing line breaks have been added.

r2_init_pos_level:
    runOnce
-> {
    var posLevel = new HashMap();
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\n")) {
            posLevel.put(key, new Integer(0));
            logger.fine(struct.getClass(), "r2_init_pos_level: initialized posLevel for position " + key);
        }
    }

    /* increase level by 1 for parent and all its descendants, but only for leaf nodes to avoid duplicate indentation */
    function increaseLevel(parent) {
        var descendants = parent.descendants();
        for (var i = 0, len = descendants.length; i < len; i++) {
            var node = descendants.get(i);
            var level = posLevel.get(node.from);
            if (level != null) {
                if (node.children().size() == 0) {
                    posLevel.put(node.from, new Integer(level+1));
                }
            }
        }
    }
}

r2_common_nodes:
      [node) basic_d
    | [node) full_cursor_body
    | [node) stmt
    | [node) case_stmt_alt
    | [node) else_clause_opt & [node^) case_stmt
    | [node) select & [node^) full_cursor_body
    | [node) excptn_handler
    | [node) prm_spec
    | [node) ',' & [node+1) prm_spec
    | [node) adt_field
    | [node) ',' & [node+1) adt_field
    | [node) body_adt_field
    | [node) subquery_factoring_clause
    | [node) subquery & [node^) par_subquery
    | [node) assoc_arg
    | [node) ',' & [node+1) assoc_arg
    | [node) arg
    | [node) ',' & [node+1) arg
    | [node) field
    | [node) ',' & [node+1) field
;

r2_body_nodes:
      [node) subprg_body
    & [parent) pkg_body
    & parent < node
;

r2_populate_pos_level:
      r2_common_nodes
    | r2_body_nodes
-> {
    increaseLevel(tuple.get("node"));
}

r2_indent_nodes:
    runOnce
-> {
    var it = posLevel.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var level = posLevel.get(key);
        var value = newlinePositions.get(key);
        var spaces = value.length()-value.lastIndexOf("\n")-1; // 0 = first column
        var comma = 0;
        var spacesAfterComma = 0;
        if (key < target.getSrc().size()) {
            if (target.getSrc().get(key).content == ",") {
               comma = 1;
               var indentAfterComma = getIndent(new Integer(key+1));
               if (!indentAfterComma.contains("\n")) {
                  spacesAfterComma = indentAfterComma.length();
               }
            }
        }
        if (level*indentSpaces >= spaces) {
            for (var i=0; i<level*indentSpaces-spaces-comma-spacesAfterComma; i++) {
                value+=" ";
            }
            struct.putNewline(key, value);
            logger.fine(struct.getClass(), "r2_indent_nodes: fixed indentation for position " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R-6: Call parameters aligned, operators aligned, values aligned.
-- --------------------------------------------------------------------------------------------------------------------

-- --------------------------------------------------------------------------------------------------------------------
-- R-7: SQL keywords are right aligned within a SQL command.
-- --------------------------------------------------------------------------------------------------------------------

-- --------------------------------------------------------------------------------------------------------------------
-- A-4: Split long lines.
-- --------------------------------------------------------------------------------------------------------------------

-- This must run at the very end to override SQLDev's default behavior.
-- SQL Developer adds a line break after the token that exceeds max char line width.
-- This behaviour is not wanted, since the indentation is not added.
-- This piece of code addresses this issue. It adds a new line with the indentation of the current line
-- plus one additional indentation (for long lines).
-- It's important to note that the lines may be a bit longer than the configured max char line width.
-- That's expected and matches the SQLDev logic. It ensures also that corner cases can be handled by
-- this code (e.g. string tokens > max char line width).
-- Due to this simple algorithm, it is expected that a subsequent formatter call will produce a different result.

a4_add_line_breaks_with_indent:
    runOnce
-> {
    var pos = 0;
    var indent = System.lineSeparator(); /* handle first line */
    for (var key=0; key<target.getSrc().size(); key++) {
        if (pos > maxCharLineSize && target.getSrc().get(key).content.length() > 1 && !getIndent(key).contains("\n")) {
            struct.putNewline(key, indent + getSpaces(indentSpaces));
            pos = indent.length() + indentSpaces + target.getSrc().get(key).content.length();
            logger.fine(struct.getClass(), "a4_add_line_breaks_with_indent: added line break at position " + key);
        } else {
            var value = getIndent(key);
            if (value.contains("\n")) {
                pos = numCharsAfterNewLine(value);
                indent = System.lineSeparator() + getSpaces(pos);
            } else {
                pos += numCharsAfterNewLine(value);
            }
            pos += target.getSrc().get(key).content.length();
        }
    }
}
