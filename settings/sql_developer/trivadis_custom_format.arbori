/*
 * Copyright 2021 Philipp Salvisberg <philipp.salvisberg@trivadis.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Lightweight Formatter for SQL Developer and SQLcl
 * The idea is to keep the code formatted "as is" and apply chosen formatting rules only.
 *
 * The Arbori program is processed from top to bottom in a single file.
 * No include files are used. The reason is, that SQLDev 20.4.1
 * cannot include files based on relative paths and absolute paths are not feasible.
 *
 * To structure the Arbori program the concept of "phases" and "sections" are used.
 * A phase consists of one ore more sections.
 * A section consists of one or more Arbori queries.
 *
 * The following phases and sections are defined:
 *
 * - Phase 1 - Initialization and preprocessing.
 *     - D1: Initialize timer.
 *     - I1: Minimal Arbori program (expected by the formatter).
 *     - I2: Globals.
 *     - I3: Remove duplicate empty lines.
 *     - I4: Keep existing whitespace.
 *
 * - Phase 2 - Processing section by section. The processing order is important.
 *     - A1: Do not use tabs.
 *     - A2: Remove trailing spaces.
 *     - A3: Do not format code between @formatter:off and @formatter:on comments.
 *     - O2: White Space: Around operators. Options: true; false. (spaceAroundOperators).
 *     - O3: White Space: Around parenthesis. Options: Default; Inside; Outside; No space. (spaceAroundBrackets).
 *     - A5: No space before node.
 *     - A6: No space after node.
 *     - A7: One space before node.
 *     - A8: One space after node.
 *     - R3: One command per line & R4: Keywords "loop", "else", "elsif", "end", "when" on a new line.
 *     - O6: Line Breaks: SELECT/FROM/WHERE. Options: true; false. (breaksAfterSelect).
 *     - O12: Line Breaks: IF/CASE/WHILE. Options: Indented Actions, Inlined Conditions;
 *            Terse (line breaks only after actions); Line breaks after Conditions and Actions;
 *            Indented Conditions and Actions. (flowControl).
 *     - O1: Line Breaks: On concatenation. Options: Before; After; No Breaks. (breaksConcat).
 *     - O9: Line Breaks: On Boolean connectors. Options: Before&After; Before; After; No Breaks.
 *           (breaksAroundLogicalConjunctions).
 *     - O10: Line Breaks: On ANSI joins. Options: true; false. (breakAnsiiJoin).
 *     - O11: Line Breaks: On subqueries. Options: true; false. (breakOnSubqueries).
 *     - R5: Commas in front of separated elements.
 *     - R2: 3 space indention.
 *     - R7: SQL keywords are right aligned within a SQL command.
 *     - A11: Align parameter names.
 *     - A10: Align parameter modes.
 *     - O8: Alignment: Type Declarations. Options: true; false. (alignTypeDecl).
 *     - O4: Alignment: Assignment Operator :=. Options: true; false. (alignAssignments).
 *     - O5: Alignment: Column and Table aliases. Options: true; false. (alignTabColAliases).
 *     - O7: Alignment: Equality Predicate =. Options: true; false. (alignEquality).
 *     - R6: Call parameters aligned, operators aligned, values aligned.
 *     - A9: Align xmltable columns.
 *     - A4: Split long lines.
 *     - D2: Log time spent in this program.
 *
 * The start of a phase is visualized by a comment series like this
 *
 * -- ================================
 * -- Phase <PhaseNumber> - <Comment>.
 * -- ================================
 *
 * The sections have the following format <Category><SectionNumber>.
 * The next table explains the meaning of a category:
 *
 * Cat.  Meaning                 Description                                             Phases
 * ----  ----------------------  ------------------------------------------------------  ------
 * D     Debug                   Initialize or produce debugging output.                 1, 2
 * I     Initialization Section  Identifies a section in an initialization phase.        1
 * O     SQLDev Option           Implements a SQL Developer option (Advanced Format).    2
 * R     Trivadis Rule           Implements a Trivadis PL/SQL & SQL Guideline.           2
 * A     Add-on Section/Rule     Additional formatting rule, that is not based on        2
 *                               the Trivadis PL/SQL & SQL Guidelines. Nonetheless it's
 *                               considered important to improve the formatting result.
 *
 * The SectionNumber identifies a section within a category.
 *
 * The start of a section is visualized by a comment series like this
 *
 * -- -------------------------------------
 * -- <Category><SectionNumber>: <Comment>.
 * -- -------------------------------------
 *
 * The lightweight formatter honors most of the SQLDev options. However, the following options
 * are ignored, have limitations or are considered only partially:
 *
 * - Indentation: indent with. Options: Tab; Spaces. (useTab).
 *   The formatter supports only indentation with spaces. Spaces are used even if "Tab" is configured.
 *   Using tab would lead to various issues in combination with other settings (e.g. leading commas).
 *
 * - Line Breaks: Commas per line in procedures. Options: Integer value. (breaksProcArgs).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * - Line Breaks: For compound_condition parenthesis. Options: true; false. (breakParenCondition).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * - Line Breaks: After statements. Options: Double break; Single break; Preserve original. (extraLinesAfterSignificantStatements).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * The following SQL options are honored, but not implemented by this Arbori program.
 * They are implemented by SQLDev's oracle.dbtools.app.Format class. As a result the behavior cannot be overridden.
 *
 * - Format:
 *   - Convert Case Only. Options: true, false. (adjustCaseOnly).
 * - Advanced Format:
 *   - General: Keywords case. Options: UPPER; lower; Init cap; Keep unchanged. (kwCase).
 *   - General: Identifiers case. Options: UPPER; lower; Init cap; Keep unchanged. (idCase).
 *   - General: 1-line long comments. Options: Keep unchanged; Wrap multiline; Wrap singleline. (singleLineComments).
 *   - Line Breaks: Before line comments. Options: true; false. (forceLinebreaksBeforeComment).
 */

-- ====================================================================================================================
-- Phase 1 - Initialization and pre-processing.
-- ====================================================================================================================

-- --------------------------------------------------------------------------------------------------------------------
-- D1: Initialize timer.
-- --------------------------------------------------------------------------------------------------------------------

startCustomFormat:
    [runOnce) sql_statements
-> {
    var startTime = (new Date()).getTime();
}

-- --------------------------------------------------------------------------------------------------------------------
-- I1: Minimal Arbori program (expected by the formatter).
-- --------------------------------------------------------------------------------------------------------------------

-- Callback function to ensure numeric literals are formatted correctly (without whitespaces)
dontFormatNode:
    [node) numeric_literal
->
;

-- ":indentCondtions" must be used, otherwise the Arbori program will be considered invalid and the default is used.
-- This rule is never called, hence it does not matter what node is selected.
-- However, I chose to use "identifier" to avoid an Arbori warning.
dummy:
    :indentConditions & [node) identifier
;

-- "skipWhitespaceBeforeNode" must be defined, otherwise the Arbori program will be considered invalid and the default is used.
skipWhiteSpaceBeforeNode:
  [runOnce) sql_statements
-> {
    var doNotCallCallbackFunction;
}

-- analytic functions, to be treated as keywords
"analytics":
      [identifier) identifier
    & [call) analytic_function
    & [call = [identifier
;

-- all identifiers
"ids":
    [identifier) identifier
;

-- Callback function to reduce the list of keywords by the identifiers provided here
identifiers:
    "ids" - "analytics"
->
;

-- --------------------------------------------------------------------------------------------------------------------
-- I2: Globals.
-- --------------------------------------------------------------------------------------------------------------------

-- Global variables, which are likely to be used in more than one Arbori query/action
define_global_variables:
    [runOnce) sql_statements
-> {
    // Java classes
    var ArrayList = Java.type('java.util.ArrayList');
    var Format = Java.type('oracle.dbtools.app.Format');
    var HashMap = Java.type('java.util.HashMap');
    var HashSet = Java.type('java.util.HashSet');
    var Integer = Java.type('java.lang.Integer');
    var LexerToken = Java.type('oracle.dbtools.parser.LexerToken');
    var logger = Java.type('oracle.dbtools.util.Logger');
    var Substitutions = Java.type('oracle.dbtools.parser.Substitutions');
    var System = Java.type('java.lang.System');
    var Token = Java.type('oracle.dbtools.parser.Token');

    // use reflection to access hidden field newlinePositions
    var newlinePositionsField = Format.class.getDeclaredField("newlinePositions");
    newlinePositionsField.setAccessible(true);
    var newlinePositions = newlinePositionsField.get(struct);

    // get option for "Alignment: Column and Table aliases"
    var alignTabColAliases = struct.options.get("alignTabColAliases");

    // get option for "Alignment: Type Declarations"
    var alignTypeDecl = struct.options.get("alignTypeDecl");

    // get option for "Alignment: Named Argument Separator =>"
    var alignNamedArgs = struct.options.get("alignNamedArgs");

    // get option for "Alignment: Assignment Operator :="
    var alignAssignments = struct.options.get("alignAssignments");

    // get option for "Alignment: Equality Predicate ="
    var alignEquality = struct.options.get("alignEquality");

    // get option for "Alignment: Right-align query keywords"
    var alignRight = struct.options.get("alignRight");

    // get option for "Indentation: Indent spaces" (number of spaces for a single indentation)
    var indentSpaces = struct.options.get("identSpaces");

    // get option for "Line Breaks: On Boolean connectors"
    var breaksAroundLogicalConjunctions = struct.options.get("breaksAroundLogicalConjunctions");

    // get option for "Line Breaks: On ANSI joins"
    var breakAnsiiJoin = struct.options.get("breakAnsiiJoin");

    // get option for "Line Breaks: On subqueries"
    var breakOnSubqueries = struct.options.get("breakOnSubqueries");

    // get option for "Line Breaks: Max char line width"
    var maxCharLineSize = struct.options.get("maxCharLineSize");

    // get option for "Line Breaks: SELECT/FROM/WHERE"
    var breaksAfterSelect = struct.options.get("breaksAfterSelect");

    // get option for "White Space: Around operators"
    var spaceAroundOperators = struct.options.get("spaceAroundOperators");

    // get option for "Whitespace: Around parenthesis"
    var spaceAroundBrackets = struct.options.get("spaceAroundBrackets");

    // lexer tokens including hidden tokens (LINE_COMMENT, COMMENT, WS, MACRO_SKIP, SQLPLUSLINECONTINUE_SKIP)
    // are relevant to find comments between tokens. These variables are populated in
    // keepSignificantWhitespaceBeforeLeafNodes
    var tokens = null;
    var mapParserPosToLexerPos = new HashMap();
}

-- Global functions, which are likely to be used in more than one Arbory action
define_global_functions:
    [runOnce) sql_statements
-> {
    /* return a string with the requested number of spaces */
    function getSpaces(numberOfSpaces) {
        var result = "";
        for (var i=0; i<numberOfSpaces; i++) {
            result += " ";
        }
        return result;
    }

    /* return the indentation at a node position, converts the default null to a single space */
    function getIndent(nodeFrom) {
        var indent = newlinePositions.get(new Integer(nodeFrom));
        if (indent == null) {
            return " ";
        }
        return indent;
    }

    /* returns the indentation without leading new lines from a string */
    function getNumCharsAfterNewLine(indent) {
        if (indent.contains("\n")) {
            return indent.length() - indent.lastIndexOf("\n") - 1;
        }
        return indent.length();
    }

    /* returns the leading new lines from a node position (without trailing spaces) */
    function getLeadingNewLines(nodeFrom) {
        var startPos=nodeFrom;
        var indent = getIndent(startPos);
        if (indent.contains("\n")) {
            return indent.substring(0, indent.lastIndexOf("\n") + 1);
        }
        return "";
    }

    /* returns the column of a node position, considers all preceding nodes */
    function getColumn(nodeFrom) {
        var startPos=nodeFrom;
        var col=getNumCharsAfterNewLine(getIndent(startPos));
        var indent = getIndent(startPos);
        for (var i=startPos-1; i>=0 && !indent.contains("\n"); i=i-1) {
            col += target.getSrc().get(i).content.length();
            var indent = getIndent(i);
            col += getNumCharsAfterNewLine(indent);
        }
        return col;
    }

    /* same as getColumn, but does not contain the very first indentation */
    function getColumnWithoutFirstIndent(nodeFrom) {
        var startPos=nodeFrom;
        var col=getNumCharsAfterNewLine(getIndent(startPos));
        var indent = getIndent(startPos);
        for (var i=startPos-1; i>=0 && !indent.contains("\n"); i=i-1) {
            col += target.getSrc().get(i).content.length();
            var indent = getIndent(i);
            if (!indent.contains("\n")) {
                col += getNumCharsAfterNewLine(indent);
            }
        }
        return col;
    }

    /* returns true if a node or one of its children contains an indentation with a new line character */
    function containsLineBreak(node) {
        for (var i = node.from; i < node.to; i++) {
            var value = getIndent(i);
            if (value.contains("\n")) {
                return true;
            }
        }
    }

    /* returns true if single-line or multi-line comments exists between two node positions */
    function hasCommentsBetweenPos(startPos, endPos) {
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                return true;
            }
        }
        return false;
    }

    /* returns the the last comment (sl or ml) between two node positions */
    function getLastCommentBetweenPos(startPos, endPos) {
        var comment = "";
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                comment = tokens[i].content;
            }
        }
        return comment;
    }

    /* returns the maximum column of nodes in an array list of tuples */
    var getMaxColumn = function(list, nodeName) {
        var maxCol = 0;
        for (var i=0; i < list.length; i++) {
            var node = list.get(i).get(nodeName)
            var col = getColumn(node.from);
            if (col > maxCol) {
                maxCol = col;
            }
        }
        return maxCol;
    }

    /* adds a tuple to a map indexed by scope */
    var addTupleToMap = function (tuple, scopeNodeName, map) {
        var scope = tuple.get(scopeNodeName);
        var list = map.get(scope);
        if (list == null) {
            list = new ArrayList();
        }
        list.add(tuple);
        map.put(scope, list);
    }

    /* increase the indent for a parent and all its descendants, but only for leaf nodes to avoid duplicate indentation */
    var addIndent = function(parent, increaseBy) {
        if (parent != null) {
            var descendants = parent.descendants();
            for (var i = 0, len = descendants.length; i < len; i++) {
                var node = descendants.get(i);
                var indent = getIndent(node.from);
                if (indent.contains("\n")) {
                    if (node.children().size() == 0) {
                        struct.putNewline(node.from, indent + getSpaces(increaseBy));
                    }
                }
            }
        }
    }

    /* aligns all nodes per scope */
    var align = function(map, alignNodeName, indentNodeName, logText) {
        var it = map.keySet().iterator();
        while (it.hasNext()) {
            var scope = it.next();
            var list = map.get(scope);
            var maxCol = getMaxColumn(list, alignNodeName);
            alignAtPos(maxCol, list, alignNodeName, indentNodeName, logText);
        }
    }

    /* aligns all nodes at a target position */
    var alignAtPos = function(targetPos, list, alignNodeName, indentNodeName, logText) {
        for (var i=0; i<list.length; i++) {
            var alignNode = list.get(i).get(alignNodeName);
            var indent = getIndent(alignNode.from);
            var col = getColumn(alignNode.from);
            if (targetPos != col) {
                if (targetPos > col) {
                    indent += getSpaces(targetPos - col);
                } else {
                    indent = indent.substr(0, targetPos + 1);
                }
                struct.putNewline(alignNode.from, indent);
                logger.fine(struct.getClass(), logText + ": at " + alignNode.from);
                if (indentNodeName != null) {
                    var indentNode = list.get(i).get(indentNodeName);
                    if (indentNode != null) {
                        addIndent(indentNode, targetPos - col);
                        logger.fine(struct.getClass(), logText + ": add indent for " + indentNode.from);
                    }
                }
            }
        }
    }

    /* returns the content of the token position range */
    var getContent = function(fromPos, toPos) {
        var content = "";
        for (var i=fromPos; i<toPos; i++) {
            content += target.getSrc().get(i).content;
            content += getIndent(i+1);
        }
        return content;
    }

    /* returns the content of the last line in a text */
    var getLastLine = function(text) {
        if (text != null) {
            var index = text.lastIndexOf("\n");
            if (index > 0) {
                return text.substr(text, index);
            }
        }
        return text;
    }

    /* returns true if there is no other parameter defined on the same line */
    var firstParameterOnLine = function(nodeFrom, scopeFrom) {
        if (!getIndent(nodeFrom).contains("\n")) {
            for (var i=nodeFrom-1; i>=scopeFrom; i=i-1) {
                var prevNode = target.getRoot().leafAtPos(i);
                if (prevNode.contains("decl_id")) {
                    return false;
                }
                if (getIndent(prevNode.from).contains("\n")) {
                    break;
                }
            }
        }
        return true;
    }

    /* returns true if there is a a new line in the node range, search backwards */
    var hasNewline = function(from, to) {
        for (var i=from; i>=to; i=i-1) {
            if (getIndent(i).contains("\n")) {
                return true;
            }
        }
        return false;
    }

    /* reduce indentation for nodes with leading commas */
    var fixIndentOfLeadingCommas = function(map, nodeName, logText) {
        if (struct.breaksBeforeComma()) {
            var comma = 1;
            if (spaceAfterCommas) {
                comma += 1;
            }
            var it = map.keySet().iterator();
            while (it.hasNext()) {
                var scope = it.next();
                var list = map.get(scope);
                for (var i=0; i<list.length; i++) {
                    var node = list.get(i).get(nodeName);
                    var indent = getIndent(node.from);
                    if (indent.contains("\n")) {
                        var content = target.getSrc().get(node.from).content;
                        if (content == ",") {
                            struct.putNewline(node.from, indent.substr(0, indent.length - comma));
                            logger.fine(struct.getClass(), logText + ": reduced intent at " + node.from);
                        }
                    }
                }
            }
        }
    }

    /* remove leading spaces after last newline character from indent */
    var removeLeadingSpaces = function(nodeFrom) {
        var indent = getIndent(nodeFrom);
        var nlpos = indent.getLastIndexOf("\n") + 1;
        if (nlpos > 0) {
            struct.putNewline(node.from, indent.substr(0, nlpos));
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- I3: Remove duplicate empty lines.
-- --------------------------------------------------------------------------------------------------------------------

-- Replace multiple, consecutive empty lines with one empty line.
-- This code changes the input (target.input) and the lexer tokens (target.src).
-- Therefore this code must run at the beginning of the Arbori program.
max_one_empty_line:
    [runOnce) sql_statements
-> {
    var offOnRanges = [];

    var populateOffOnRanges = function(tokens) {
        var off = -1;
        offOnRanges = [];
        for (var i in tokens) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                if (tokens[i].content.toLowerCase().contains("@formatter:off") || tokens[i].content.toLowerCase().contains("noformat start")) {
                    off = tokens[i].begin;
                }
                if (off != -1) {
                    if (tokens[i].content.toLowerCase().contains("@formatter:on") || tokens[i].content.toLowerCase().contains("noformat end")) {
                        offOnRanges.push([off, tokens[i].end]);
                        off = -1;
                    }
                }
            }
        }
    }

    var inOffOnRange = function(pos) {
        for (var x in offOnRanges) {
            if (pos >= offOnRanges[x][0] && pos < offOnRanges[x][1]) {
                return true;
            }
        }
        return false;
    }

    var removeDuplicateEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var firstEOLToken = 0;
        var secondEOLToken = 0;
        var lastEOLToken = 0;
        for (i = 0; i < tokens.length; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT && firstEOLToken == 0) {
                firstEOLToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (firstEOLToken == 0) {
                    firstEOLToken = tokens[i];
                } else if (secondEOLToken == 0) {
                    secondEOLToken = tokens[i];
                } else {
                    lastEOLToken = tokens[i];
                }
                continue;
            }
            if (type != Token.WS) {
                if (lastEOLToken != 0) {
                    if (!inOffOnRange(secondEOLToken.begin)) {
                        substitutions.put(secondEOLToken.begin,lastEOLToken.begin,"");
                    }
                }
                firstEOLToken = 0;
                secondEOLToken = 0;
                lastEOLToken = 0;
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    var removeWSOnEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var eolToken = 0
        for (i = 0; i < tokens.length; i++) {
            var type = tokens[i].type;
            if (type != Token.WS) {
                eolToken = 0;
                continue;
            }
            if (eolToken == 0 && (type == Token.LINE_COMMENT || tokens[i].content == "\n")) {
                eolToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (eolToken != 0) {
                    if (!inOffOnRange(eolToken.end)) {
                        substitutions.put(eolToken.end,tokens[i].begin,"");
                    }
                }
                eolToken = tokens[i];
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    // replacements
    removeDuplicateEmptyLines();
    removeWSOnEmptyLines();

    // tokens without WS and comments (mimicking default behaviour)
    var Lexer = Java.type('oracle.dbtools.parser.Lexer');
    var defaultTokens = Lexer.parse(target.input);

    // produce a new parse tree based on the updated lexer tokens
    var Parsed = Java.type('oracle.dbtools.parser.Parsed');
    var SqlEarley = Java.type('oracle.dbtools.parser.plsql.SqlEarley')
    var newTarget = new Parsed(target.input, defaultTokens, SqlEarley.getInstance(), Java.to(["sql_statements"], "java.lang.String[]"));

    // update token list based on fixed source code (without WS tokens)
    target.src.clear();
    target.src.addAll(newTarget.src);

    // enable next line to print all node names on the console (e.g. when SQLDev UI shows unnamed nodes)
    // target.root.printTree();
}

-- --------------------------------------------------------------------------------------------------------------------
-- I4: Keep existing whitespace.
-- --------------------------------------------------------------------------------------------------------------------

-- add explicit whitespace before each leaf node, if the whitespace before is not a single space (default)
keep_significant_whitespace_before_leaf_nodes:
    [runOnce) sql_statements
-> {
    tokens = LexerToken.parse(target.input, true);  // include hidden tokens not relevant to build a parse tree
    var hiddenTokenCount = 0;
    var wsBefore = "";
    for (var i in tokens) {
        var type = tokens[i].type;
        // count hidden tokens
        if (type == Token.LINE_COMMENT || type == Token.COMMENT || type == Token.WS ||
            type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP)
        {
            hiddenTokenCount++;
            // concatenate whitespace before a node
            if (type == Token.WS) {
                wsBefore += tokens[i].content;
            } else {
                // ensure that other hidden token are not counted as whitespace
                wsBefore = "";
            }
        } else {
            mapParserPosToLexerPos.put(new Integer(i-hiddenTokenCount), i);
            if (wsBefore != " ") {
                // add collected whitespace before leaf node (actually at the position of the leaf node)
                // add also empty strings to ensure that not a space is added between tokens
                struct.putNewline(i-hiddenTokenCount, wsBefore);
                logger.fine(struct.getClass(), "keepSignificantWhitespaceBeforeLeafNodes: add "
                    + wsBefore.length() + " whitespace at " + (i-hiddenTokenCount));
            }
            wsBefore = "";
        }
    }
}

-- ====================================================================================================================
-- Phase 2 - Processing section by section.
-- ====================================================================================================================

-- --------------------------------------------------------------------------------------------------------------------
-- A1: Do not use tabs.
-- --------------------------------------------------------------------------------------------------------------------

-- replace tabs with the configured indentation (default is 3)
a1_replace_tabs_with_spaces:
    [runOnce) sql_statements
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\t")) {
            struct.putNewline(key, value.replaceAll("\t", indent));
            logger.fine(struct.getClass(), "a1_replace_tabs_with_spaces: at " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A2: Remove trailing spaces.
-- --------------------------------------------------------------------------------------------------------------------

a2_remove_trailing_spaces:
    [runOnce) sql_statements
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        // handle Linux and Windows line separators regardless of the OS
        var newValue = value.replaceAll("[ ]+\\n", "\n").replaceAll("[ ]+\\r\\n", "\r\n");
        if (!value.equals(newValue)) {
            struct.putNewline(key, newValue);
            logger.fine(struct.getClass(), "a2_remove_trailing_spaces: at " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A3: Do not format code between @formatter:off and @formatter:on comments.
-- --------------------------------------------------------------------------------------------------------------------

a3_dont_format_off_on_ranges:
    [runOnce) sql_statements
-> {
    var hiddenTokenCount = 0;
    var format = true;
    for (var i in tokens) {
        var type = tokens[i].type;
        if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
            var content = tokens[i].content.toLowerCase();
            if (content.contains("@formatter:off") || content.contains("noformat start")) {
                format = false;
            }
            if (content.contains("@formatter:on") || content.contains("noformat end")) {
                format = true;
            }
            hiddenTokenCount++;
        } else if (type == Token.WS || type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP) {
            hiddenTokenCount++
        } else {
            /* expected types: QUOTED_STRING, DQUOTED_STRING, BQUOTED_STRING, DIGITS, OPERATION, IDENTIFIER, AUXILIARY, INCOMPLETE */
            if (!format) {
                var pos = new Integer(i-hiddenTokenCount);
                struct.unformattedPositions.add(pos);
                logger.fine(struct.getClass(), "a3_dont_format_off_on_ranges: at " + pos);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O2: White Space: Around operators. Options: true; false. (spaceAroundOperators).
-- --------------------------------------------------------------------------------------------------------------------

o2_whitespace_around_operators:
      [node) '<'
    | [node) '>'
    | [node) '='
    | [node) '!'
    | [node) '~'
    | [node) '^'
    | [node) '+'
    | [node) '-'
    | [node) '*'
    | [node) '/' & ![node-1) block_stmt & ![node-1) create_plsql
    | [node) '|'
    | [node) ':'
-> {
    var node = tuple.get("node");
    var space;
    if (spaceAroundOperators) {
       space = " ";
    } else {
       space = "";
    }
    if (!getIndent(node.from).contains("\n")) {
        struct.putNewline(node.from, space);
        logger.fine(struct.getClass(), "o2_whitespace_around_operators: before at " + node.from);
    }
    if (!getIndent(node.to).contains("\n")) {
        struct.putNewline(node.to, space);
        logger.fine(struct.getClass(), "o2_whitespace_around_operators: after at " + node.to);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O3: White Space: Around parenthesis. Options: Default; Inside; Outside; No space. (spaceAroundBrackets).
-- --------------------------------------------------------------------------------------------------------------------

o3_whitespace_around_open_paren:
     [node) '('
-> {
    var node = tuple.get("node");
    if (spaceAroundBrackets != Format.Space.Default) {
        if (!getIndent(node.from).contains("\n")) {
            var spaceBefore;
            if (spaceAroundBrackets == Format.Space.Inside || spaceAroundBrackets == Format.Space.NoSpace) {
                spaceBefore = "";
            } else {
                spaceBefore = " ";
            }
            struct.putNewline(node.from, spaceBefore);
            logger.fine(struct.getClass(), "o3_whitespace_around_open_paren: <" + spaceBefore + "> before at " + node.from);
        }
    }
    if (!getIndent(node.to).contains("\n")) {
        var spaceAfter;
        if (spaceAroundBrackets ==  Format.Space.Outside || spaceAroundBrackets == Format.Space.NoSpace || spaceAroundBrackets == Format.Space.Default) {
            spaceAfter = "";
        } else {
            spaceAfter = " ";
        }
        struct.putNewline(node.to, spaceAfter);
        logger.fine(struct.getClass(), "o3_whitespace_around_open_paren: <" + spaceAfter + "> after at " + node.to);
    }
}

o3_whitespace_around_close_paren:
   [node) ')'
-> {
    var node = tuple.get("node");
    if (!getIndent(node.from).contains("\n")) {
        var spaceBefore;
        if (spaceAroundBrackets == Format.Space.Outside || spaceAroundBrackets == Format.Space.NoSpace || spaceAroundBrackets == Format.Space.Default) {
            spaceBefore = "";
        } else {
            spaceBefore = " ";
        }
        struct.putNewline(node.from, spaceBefore);
        logger.fine(struct.getClass(), "o3_whitespace_around_close_paren: <" + spaceBefore + "> before at " + node.from);
    }
    if (spaceAroundBrackets != Format.Space.Default) {
        if (!getIndent(node.to).contains("\n")) {
            var spaceAfter;
            if (spaceAroundBrackets ==  Format.Space.Inside || spaceAroundBrackets == Format.Space.NoSpace) {
                spaceAfter = "";
            } else {
                spaceAfter = " ";
            }
            struct.putNewline(node.to, spaceAfter);
            logger.fine(struct.getClass(), "o3_whitespace_around_close_paren: <" + spaceAfter + "> after at " + node.to);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A5: No space before node.
-- --------------------------------------------------------------------------------------------------------------------

a5_semicolon:
    [node) ';'
;

a5_dot:
    [node) '.'
;

a5_concat:
      [node-1) '|'
    & [node) '|'
;

a5_not_equal:
      [node-1) '<' & [node) '>'
    | [node-1) '!' & [node) '='
    | [node-1) '^' & [node) '='
    | [node-1) '~' & [node) '='
;

a5_assignment:
      [node-1) ':'
    & [node) '='
;

a5_greater_equal:
      [node-1) '>'
    & [node) '='
;

a5_less_equal:
      [node-1) '<'
    & [node) '='
;

a5_greater_greater:
      [node-1) '>' & [node) '>'
    | [node) '>' & [node+1) '>'
;

a5_less_less:
      [node-1) '<'
    & [node) '<'
;

a5_param_assoc:
      [node-1) '='
    & [node) '>'
;

a5_percent:
      [node) '%'
;

a5_at:
      [node) '@'
;

a5_slash:
     ([node-1) block_stmt | [node-1) create_plsql)
   & [node) '/'
;

a5_no_space_before:
      a5_semicolon
    | a5_dot
    | a5_concat
    | a5_not_equal
    | a5_assignment
    | a5_greater_equal
    | a5_less_equal
    | a5_greater_greater
    | a5_less_less
    | a5_param_assoc
    | a5_percent
    | a5_at
    | a5_slash
-> {
    var node = tuple.get("node");
    var content = target.getSrc().get(node.from).content;
    if (content == '/') {
        struct.putNewline(node.from, System.lineSeparator());
        logger.fine(struct.getClass(), "a5_no_space_before: <" + content + ">, add line break at " + node.from);
    } else if (content != '.' || !getIndent(node.from).contains("\n")) {
        // support fluent type methods across multiple lines
        struct.putNewline(node.from, "");
        logger.fine(struct.getClass(), "a5_no_space_before: <" + content + "> at " + node.from);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A6: No space after node.
-- --------------------------------------------------------------------------------------------------------------------

a6_dot:
    [node) '.'
;

a6_less_less:
      [node-1) '<'
    & [node) '<'
;

a6_no_space_after:
      a6_dot
    | a6_less_less
-> {
    var node = tuple.get("node");
    struct.putNewline(node.to, "");
    var content = target.getSrc().get(node.from).content;
    logger.fine(struct.getClass(), "a6_no_space_after: <" + content + "> at " + node.to);
}

-- --------------------------------------------------------------------------------------------------------------------
-- A7: One space before node.
-- --------------------------------------------------------------------------------------------------------------------

a7_param_list:
    [node) fml_part
;

a7_as_alias:
    [node) as_alias
;

a7_table_alias:
      [node) identifier
    & [node-1) query_table_expression
;

a7_one_space_before:
      a7_param_list
    | a7_as_alias
    | a7_table_alias
-> {
    var node = tuple.get("node");
    if (!hasCommentsBetweenPos(node.from, node.to)) {
        struct.putNewline(node.from, " ");
        var content = target.getSrc().get(node.from).content;
        logger.fine(struct.getClass(), "a7_one_space_before: <" + content + "> at " + node.from);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A8: One space after node.
-- --------------------------------------------------------------------------------------------------------------------

a8_if:
      ![node+1) ';'
    & [node) 'IF'
;

a8_for_identifier:
     [node-1) 'FOR'
   & [node) identifier
;

a8_as:
      [node) 'AS'
    & [node^) as_alias
;

a8_on:
      [node) 'ON'
    & [node^) on_using_condition
;

a8_join:
    [node) 'JOIN'
;

a8_from:
      [node) 'FROM'
    & [node^) from_clause
;

a8_create_or_replace:
      [node) 'CREATE'
    | [node) 'OR' & [node-1) 'CREATE'
    | [node) 'REPLACE' & [node-1) 'OR' & [node-2) 'CREATE'
    | [node) 'PACKAGE'
    | [node) 'BODY'
    | [node) 'VIEW'
    | [node) 'PROCEDURE'
    | [node) 'FUNCTION'
    | [node) 'TYPE' & ![node-1) '%'
;

a8_case:
    [node) 'CASE' & [node+1) simple_case_expression
;

a8_select_clauses:
      [node) 'SELECT'
    | [node) 'INTO'
    | [node) 'FROM'
    | [node) 'WHERE'
    | [node) 'CONNECT'
    | [node) 'BY'
    | [node) 'START' & [node+1) 'WITH'
    | [node) 'WITH' & [node-1) 'START'
    | [node) 'GROUP'
    | [node) 'HAVING'
    | [node) 'ORDER'
;

a8_one_space_after:
      a8_if
    | a8_for_identifier
    | a8_as
    | a8_on
    | a8_join
    | a8_from
    | a8_create_or_replace
    | a8_case
    | a8_select_clauses
-> {
    var node = tuple.get("node");
    if (!hasCommentsBetweenPos(node.from, node.to)) {
        struct.putNewline(node.to, " ");
        var content = target.getSrc().get(node.from).content;
        logger.fine(struct.getClass(), "a8_one_space_after: <" + content + "> at " + node.to);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R3: One command per line.
-- R4: Keywords "loop", "else", "elsif", "end", "when" on a new line.
-- --------------------------------------------------------------------------------------------------------------------

r3_stmt_in_first_conditional_compilation_branch:
    [runOnce) sql_statements
-> {
    var posInConditionalBranch = new HashSet();
    var pos = 0;
    var withinFirstBranch = false;
    for (i = 0; i < tokens.length; i++) {
        var type = tokens[i].type
        var content = tokens[i].content.toLowerCase()
        if (type == Token.MACRO_SKIP && content.startsWith("$if ")) {
            withinFirstBranch = true;
            continue;
        }
        if (withinFirstBranch && type == Token.MACRO_SKIP && content.startsWith("$")) {
            withinFirstBranch = false;
            continue;
        }
        if (type != Token.WS && type != Token.MACRO_SKIP && type != Token.COMMENT && type != Token.LINE_COMMENT) {
            if (withinFirstBranch) {
                posInConditionalBranch.add(new Integer(pos));
                logger.fine(struct.getClass(), "r3_stmt_in_first_conditional_compilation_branch: ignore node at " + pos);
            }
            pos++;
        }
    }
}

r3_sqlplus_commands:
    [node) sqlplus_command
;

r3_sql_commands:
    [node) sql_statement
;

r3_plsql_commands:
      [node) subprg_spec
          & ![node^^) create            -- standalone function/procedure
          & ![node-1) member_or_static  -- object type spec
          & ![node^-1) member_or_static -- object type body
          & ![node-1) 'CONSTRUCTOR'     -- object type spec
          & ![node^-1) 'CONSTRUCTOR'    -- object type body
    | [node) basic_decl_item
    | [node) stmt
;

r3_plsql_keywords:
      [node) 'LOOP' & ![node-1) 'END'
    | [node) 'WHEN'
          & ![node^^) exit_stmt
          & ![node^) merge_insert_clause
          & ![node^) merge_update_clause
    | [node) 'BEGIN'
    | [node) 'END'
    | [node) 'ELSIF'
    | [node) 'ELSE'
;

r3_case_expressions:
      [parent) case_expression
    & ([node) 'WHEN' | [node) 'ELSE' | [node) 'END')
    & parent < node
;

r3_commands:
      r3_sqlplus_commands
    | r3_sql_commands
    | r3_plsql_commands
    | (r3_plsql_keywords - r3_case_expressions)
-> {
    var node = tuple.get("node");
    if (!posInConditionalBranch.contains(node.from)) {
        var indent = getIndent(node.from);
        if (!indent.contains("\n")) {
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "r3_commands: add line break at " + node.from);
        } else {
            /* remove existing indentation, enforce conformity in these cases */
            var newIndent = getLeadingNewLines(node.from);
            struct.putNewline(node.from, newIndent);
            logger.fine(struct.getClass(), "r3_commands: remove indentation at " + node.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O6: Line Breaks: SELECT/FROM/WHERE. Options: true; false. (breaksAfterSelect).
-- --------------------------------------------------------------------------------------------------------------------

-- Chosen keywords on separated lines. The keywords start an indented section (see R2).
-- Not compatible with alignRight (breaksAfterSelect wins).

o6_select_before:
      [node) 'WITH'
    | [node) 'SELECT'
    | [node) 'INTO'
    | [node) 'FROM'
    | [node) 'WHERE'
    | [node) 'CONNECT'
    | [node) 'START' & [node+1) 'WITH'
    | [node) 'GROUP'
    | [node) 'HAVING'
    | [node) 'ORDER'
;

o6_select_after:
      [node) 'WITH'
    | [node) 'SELECT'
    | [node) 'INTO'
    | [node) 'FROM'
    | [node) 'WHERE'
    | [node-1) 'CONNECT' & [node) 'BY'
    | [node-1) 'START'   & [node) 'WITH'
    | [node-1) 'GROUP'   & [node) 'BY'
    | [node) 'HAVING'
    | [node-1) 'ORDER'   & [node) 'BY'
;

o6_line_break_before:
    o6_select_before
-> {
    if (breaksAfterSelect) {
        var node = tuple.get("node");
        if (!posInConditionalBranch.contains(node.from)) {
            var indent = getIndent(node.from);
            if (!indent.contains("\n")) {
                struct.putNewline(node.from, System.lineSeparator());
                logger.fine(struct.getClass(), "o6_line_break_before: at " + node.from);
            }
        }
    }
}

o6_line_break_after:
    o6_select_after
-> {
    if (breaksAfterSelect) {
        var node = tuple.get("node");
        if (!posInConditionalBranch.contains(node.to)) {
            var indent = getIndent(node.to);
            if (!indent.contains("\n")) {
                struct.putNewline(node.to, System.lineSeparator());
                logger.fine(struct.getClass(), "o6_line_break_after: at " + node.to);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O12: Line Breaks: IF/CASE/WHILE. Options: Indented Actions, Inlined Conditions;
--      Terse (line breaks only after actions); Line breaks after Conditions and Actions;
--      Indented Conditions and Actions. (flowControl).
-- --------------------------------------------------------------------------------------------------------------------

-- Indentation is handled in R2.
-- Line breaks are handled here.
-- WHILE condition is kept "as is", it is also not handled in SQLDev 20.4.1 / SQLcl 21.1.1.

o12_line_break_around_conditions:
      (
          [node) condition
        | [node) pls_expr
      )
    & (
          [keyword) 'WHEN'
        | [keyword) 'IF'
        | [keyword) 'ELSIF'
      )
    & node = keyword+1
-> {
    var node = tuple.get("node");
    if (struct.indentConditions()) {
        if (!getIndent(node.from).contains("\n")) {
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "o12_line_break_around_conditions: before at " + node.from);
        }
    } else {
        if (getIndent(node.from) != " ") {
            struct.putNewline(node.from, " ");
            logger.fine(struct.getClass(), "o12_line_break_around_conditions: add space before at " + node.from);
        }
    }
    if (struct.indentConditions() || struct.breakAfterConditions()) {
        if (!getIndent(node.to).contains("\n")) {
            struct.putNewline(node.to, System.lineSeparator());
            logger.fine(struct.getClass(), "o12_line_break_around_conditions: after at " + node.to);
        }
    } else {
        if (getIndent(node.to) != " ") {
            struct.putNewline(node.from, " ");
            logger.fine(struct.getClass(), "o12_line_break_around_conditions: add space after at " + node.from);
        }
    }
}

o12_line_break_before_actions:
      (
          [node) stmt
        | [node) expr
        | [node) pls_expr
      )
    & (
          [keyword) 'THEN'
        | [keyword) 'ELSE'
      )
    & node = keyword+1
-> {
    var node = tuple.get("node");
    if (struct.indentActions()) {
        if (!getIndent(node.from).contains("\n")) {
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "o12_line_break_before_actions: at " + node.from);
        }
    } else {
        if (getIndent(node.from) != " ") {
            struct.putNewline(node.from, " ");
            logger.fine(struct.getClass(), "o12_line_break_before_actions: add space at " + node.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O1: Line Breaks: On concatenation. Options: Before; After; No Breaks. (breaksConcat).
-- --------------------------------------------------------------------------------------------------------------------

-- only when expression consists of more than one concatenation (||)
-- add only missing line breaks, use indentation according column position of previous node
o1_concatenation_option:
      (:breaksBeforeConcat | :breaksAfterConcat)
    & ?node+1 = '||'
    & ([parent) arith_expr | [parent) compound_expression)
    & parent << node
-> {
    var parent = tuple.get("parent");
    var countConcat = 0;
    for (var i=parent.from; i<parent.to && countConcat < 4; i++) {
        if (target.getSrc().get(new Integer(i)).content == '|') {
            countConcat++;
        }
    }
    if (countConcat >= 4) {
        var node = tuple.get("node")
        var concat = tuple.get("node+1");
        if (struct.breaksBeforeConcat()) {
            struct.putNewline(concat.to, " "); // Before and After is not an option
            if (!getIndent(concat.from).contains("\n")) {
                struct.putNewline(concat.from, System.lineSeparator());
                logger.fine(struct.getClass(), "o1_concatenation_option: add line break before at " + concat.from);
            }
        } else if (struct.breaksAfterConcat()) {
            struct.putNewline(concat.from, " "); // Before and After is not an option
            if (!getIndent(concat.to).contains("\n")) {
                struct.putNewline(concat.to, System.lineSeparator());
                logger.fine(struct.getClass(), "o1_concatenation_option: add line break after at " + concat.to);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O9: Line Breaks: On Boolean connectors. Options: Before&After; Before; After; No Breaks.
--     (breaksAroundLogicalConjunctions).
-- --------------------------------------------------------------------------------------------------------------------

o9_boolean_in_paren:
      [node) AND_OR
    & [parent) compound_condition
    &  parent < node
    & [parent-1) '('
;

o9_boolean:
    [node) AND_OR
;

o9_boolean_option:
      (:breaksBeforeLogicalConjunction | :breaksAfterLogicalConjunction)
    & (o9_boolean - o9_boolean_in_paren)
-> {
    var node = tuple.get("node")
    if (struct.breaksBeforeLogicalConjunction()) {
        if (!getIndent(node.from).contains("\n")) {
            if (breaksAroundLogicalConjunctions != Format.Breaks.BeforeAndAfter) {
               struct.putNewline(node.to, " ");
            }
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "o9_boolean_option: add line break before at " + node.from);
        }
    }
    if (struct.breaksAfterLogicalConjunction()) {
        if (!getIndent(node.to).contains("\n")) {
            if (breaksAroundLogicalConjunctions != Format.Breaks.BeforeAndAfter) {
               struct.putNewline(node.from, " ");
            }
            struct.putNewline(node.to, System.lineSeparator());
            logger.fine(struct.getClass(), "o9_boolean_option: add line break after at " + node.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O10: Line Breaks: On ANSI joins. Options: true; false. (breakAnsiiJoin).
-- --------------------------------------------------------------------------------------------------------------------

o10_join_clause_keywords:
      [parent) from_clause
    & (
            [keyword) 'INNER'
          | [keyword) 'CROSS'
          | [keyword) 'NATURAL'
          | [keyword) 'FULL'
          | [keyword) 'LEFT'
          | [keyword) 'RIGHT'
          | [keyword) 'JOIN'
          | [keyword) 'PARTITION'
          | [keyword) 'BY'
          | [keyword) 'ON'
          | [keyword) 'USING'
          | [keyword) 'OUTER'
          | [keyword) 'APPLY'

      )
    &  parent < keyword
;

-- no break on 'PARTITION', even if it is part of the outer join clause, looks better with default settings
o10_join_clause_break_keywords:
      [parent) from_clause
    & (
            [keyword) 'INNER'   & ![keyword-1) 'NATURAL'
          | [keyword) 'CROSS'
          | [keyword) 'NATURAL'
          | [keyword) 'FULL'    & ![keyword-1) 'NATURAL'
          | [keyword) 'LEFT'    & ![keyword-1) 'NATURAL'
          | [keyword) 'RIGHT'   & ![keyword-1) 'NATURAL'
          | [keyword) 'JOIN'
              & ![keyword-1) 'INNER'
              & ![keyword-1) 'CROSS'
              & ![keyword-1) 'NATURAL'
              & ![keyword-1) outer_join_type
              & ![keyword-1) "inner_cross_join_clause"[26,55)
          --| [keyword) 'PARTITION'
          | [keyword) 'ON'
          | [keyword) 'USING'
          | [keyword) 'OUTER' & [keyword+1) 'APPLY'
      )
    &  parent < keyword
;

o10_space_around_join_keywords:
    o10_join_clause_keywords - o10_join_clause_break_keywords
-> {
    if (breakAnsiiJoin) {
        var keyword = tuple.get("keyword");
        if (!getIndent(keyword.from) != " ") {
            struct.putNewline(keyword.from, " ");
            logger.fine(struct.getClass(), "o10_space_around_join_keywords at " + keyword.from);
        }
        if (!getIndent(keyword.to) != " ") {
            struct.putNewline(keyword.to, " ");
            logger.fine(struct.getClass(), "o10_space_around_join_keywords at " + keyword.to);
        }
    }
}

o10_break_on_join_keywords:
    o10_join_clause_break_keywords
-> {
    if (breakAnsiiJoin) {
        var keyword = tuple.get("keyword");
        if (!getIndent(keyword.from).contains("\n")) {
            struct.putNewline(keyword.from, System.lineSeparator());
            logger.fine(struct.getClass(), "o10_break_on_join_keywords: add line break at " + keyword.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O11: Line Breaks: On subqueries. Options: true; false. (breakOnSubqueries).
-- --------------------------------------------------------------------------------------------------------------------

o11_break_on_subqueries:
      [lparen) '('
    & [node) subquery
    & [rparen) ')'
    & lparen = node-1
    & rparen = node+1
-> {
    if (breakOnSubqueries) {
        var node = tuple.get("node");
        if (hasNewline(node.to-1, node.from+1)) {
            var rparen = tuple.get("rparen");
            if (!getIndent(node.from).contains("\n")) {
                struct.putNewline(node.from, System.lineSeparator());
                logger.fine(struct.getClass(), "o11_break_on_subqueries: before subquery at " + node.from);
            }
            if (!getIndent(rparen.from).contains("\n")) {
                struct.putNewline(rparen.from, System.lineSeparator());
                logger.fine(struct.getClass(), "o11_break_on_subqueries: before ')' at " + rparen.from);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R5: Commas in front of separated elements.
-- --------------------------------------------------------------------------------------------------------------------

-- Considers the following SQLDev settings:
-- - Line Breaks On Comma
--     "Before" enforces a line break before the comma (this is rule 5)
--     "After" enforces line break after the comma
--     "No Breaks" keeps line breaks before/after comma "as is"
-- - White Space After Commas (option for lines starting with a comma)
--     "checked" enforces exactly one space after the comma
--     "unchecked" enforces no space after a comma

r5_get_prefs:
    [runOnce) sql_statements
-> {
    /* boolean true=space, false=no space */
    var spaceAfterCommas = struct.options.get("spaceAfterCommas");
}

r5_commas:
    [node) ','
-> {
    var getIndentAfterComma = function(indent) {
        var plus = 1;
        if (spaceAfterCommas) {
           plus++;
        }
        return indent + getSpaces(plus);
    }

    var getIndentForComma = function(indent) {
        var len = indent.length() - 1;
        if (spaceAfterCommas) {
           len = len - 1;
        }
        var spaces = indent.length()-indent.lastIndexOf("\n")-1;
        if (spaces > len) {
            return indent.substring(0, len);
        } else {
            return indent;
        }
    }

    var removeLeadingSpaces = function(nodeFrom) {
        var indent = getIndent(nodeFrom);
        if (indent.contains("\n")) {
            var pos = 0;
            for (var i=0; i<indent.length(); i++) {
                if (indent.substring(i, i+1) == " ") {
                    pos++;
                } else {
                    break;
                }
            }
            struct.putNewline(nodeFrom, indent.substring(pos));
        } else {
            struct.putNewline(nodeFrom, "");
        }
    }

    var addSpacesAroundComma = function(commaNode) {
        /* always handle space after comma */
        removeLeadingSpaces(commaNode.from);
        removeLeadingSpaces(commaNode.to);
        if (spaceAfterCommas) {
            var indent = getIndent(commaNode.to);
            if (!indent.contains("\n")) {
                struct.putNewline(commaNode.to, " " + indent);
            }
        } else {
            var indentCommaNode = getIndent(commaNode.from);
            var indentNextNode = getIndent(commaNode.to);
            if (!indentCommaNode.contains("\n") && !indentNextNode.contains("\n")) {
                struct.putNewline(commaNode.to, " ");
            }
        }
    }

    var addBreakAfterComma = function(commaNode) {
        var indentCommaNode = getIndent(commaNode.from);
        if (indentCommaNode.contains("\n") && !hasCommentsBetweenPos(commaNode.from-1, commaNode.to)) {
            /* situation: a new line was added before the comma instead of after */
            struct.putNewline(commaNode.to, getIndentAfterComma(indentCommaNode));
            logger.fine(struct.getClass(), "r5_commas: fix indent after comma at " + commaNode.to);
            struct.putNewline(commaNode.from, "");
        }
    }

    var addBreakBeforeComma = function(commaNode) {
        var indentCommaNode = getIndent(commaNode.from);
        if (!indentCommaNode.contains("\n")) {
            var indentNextNode = getIndent(commaNode.to);
            if (indentNextNode.contains("\n")) {
                /* situation: a new line was added after the comma instead of before */
                struct.putNewline(commaNode.from, getIndentForComma(indentNextNode));
                logger.fine(struct.getClass(), "r5_commas: fix indent before comma at " + commaNode.from);
                if (!hasCommentsBetweenPos(commaNode.from-1, commaNode.to)) {
                    /* remove all whitespace for node */
                    struct.putNewline(commaNode.to, "");
                } else {
                    var comment = getLastCommentBetweenPos(commaNode.from-1, commaNode.to);
                    if (comment.startsWith("--")) {
                       /* we must not remove the newline after a single-line comment */
                    } else {
                       /* removing newline after multi-line comment is wanted, but does not work in SQLDev 20.4.1, it would remove indentation only but keep the newline */
                       logger.fine(struct.getClass(), "r5_commas: SQLDev 20.4.1 bug: new line after a multi-line-comment cannot be set at " + commaNode.from);
                    }
                }
            }
        }
    }

    var node = tuple.get("node");
    if (struct.breaksAfterComma()) {
        addBreakAfterComma(node);
    }
    if (struct.breaksBeforeComma()) {
        addBreakBeforeComma(node);
    }
    addSpacesAroundComma(node);
}

-- --------------------------------------------------------------------------------------------------------------------
-- R2: 3 space indention.
-- --------------------------------------------------------------------------------------------------------------------

-- Determine the left margin for each position managed in newlinePositions with a newline char ("\n") and then
-- ensure that the indentation is >= the this left margin, by adding missing spaces.
-- This code must be executed after missing line breaks have been added.

r2_init_left_margin:
    [runOnce) sql_statements
-> {
    /* left margin is expressed in number of spaces. */
    var leftMargin = new HashMap();
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\n")) {
            leftMargin.put(key, new Integer(0));
        }
    }

    /* increase the left margin for the parent's descendants, but only for leaf nodes to avoid duplicate indentation */
    var addMargin = function(parent, increaseBy) {
        var descendants = parent.descendants();
        for (var i = 0, len = descendants.length; i < len; i++) {
            var node = descendants.get(i);
            var margin = leftMargin.get(node.from);
            if (margin != null) {
                if (node.children().size() == 0) {
                    leftMargin.put(node.from, new Integer(margin+increaseBy));
                }
            }
        }
    }

    /* returns the left margin of a node */
    var getMargin = function(node) {
        var i = node.from;
        while (i >= 0) {
            var margin = leftMargin.get(new Integer(i));
            if (margin != null) {
                return margin;
            }
            i--;
        }
        return null;
    }

    /* returns the first word within a string */
    var getFirstWord = function(text) {
        var i = text.indexOf(" ");
        if (i == -1) {
            return text;
        } else {
            return text.substr(0, i);
        }
    }

    /* increase left margin by keyword and SQLDev settings */
    var addMarginByName = function(parent, name) {
        var spaces;
        if (breaksAfterSelect) {
            spaces = indentSpaces;
        } else if (alignRight) {
            var firstWord = getFirstWord(name);
            if (firstWord.length > 6) {
                spaces = firstWord.length;
            } else {
                spaces = 6;
            }
            spaces = spaces + name.length - firstWord.length + 1;
        } else {
            spaces = name.length + 1;
        }
        addMargin(parent, spaces);
        return spaces;
    }

    /* Use the calculated left margin for this node? */
    var useFullLeftMargin = function(nodeFrom) {
        return hasParentOfType(nodeFrom, ["select"/*, "insert", "update", "delete", "merge"/*, "block_stmt"*/]);
    }

    /* returns true if a the node or an ancestors has one of the provided symbols */
    var hasParentOfType = function(nodeFrom, symbols) {
        var node = target.getRoot().leafAtPos(nodeFrom);
        while (node != null) {
            for (var i=0; i < symbols.length; i++) {
                if (node.contains(symbols[i])) {
                    return true;
                }
            }
            node = node.parent();
        }
        return false;
    }
}

-- TODO: delete query as soon as left margin is enforced for PL/SQL
r2_remove_indentation_for_assignment:
    [node-2) ':' & [node-1) '=' & [node) pls_expr
-> {
    var node = tuple.get("node");
    for (var i=node.from; i<node.to; i++) {
        var indent = getIndent(i);
        var index = indent.lastIndexOf("\n") + 1;
        if (index > 0) {
            struct.putNewline(i, indent.substr(0, index));
            logger.fine(struct.getClass(), "r2_remove_indentation_for_assignment: at " + i);
        }
    }
}

-- if a select statement is written on several lines, then each clause should start on a new line
r2_add_line_break:
    [parent) subquery
    & (
            [node) 'FROM'
          | [node) 'WHERE'
          | [node) 'CONNECT'
          | [node) 'START'
          | [node) 'GROUP'
          | [node) 'HAVING'
          | [node) 'ORDER'
      )
    & parent < node
-> {
    var parent = tuple.get("parent");
    var node = tuple.get("node");
    if (hasNewline(parent.to-1, parent.from+1)) {
        struct.putNewline(node.from, System.lineSeparator());
        logger.fine(struct.getClass(), "r2_add_line_break: at " + node.from);
    }
}

r2_common:
      [node) basic_d
    | [node) full_cursor_body
    | [node) stmt
    | [node) case_stmt_alt
    | [node) else_clause_opt & [node^) case_stmt
    | [node) select & [node^) full_cursor_body
    | [node) excptn_handler
    | [node) subquery_factoring_clause
    | [node) subquery & ([node-1) '(' | [node-1) 'FOR') -- "(subquery)" or "open cursor for select"
    | [node) ty_def
    | [node) fml_part
    | [node) paren_expr_list
    | [node) "expr_list" & [node-1) '('
    | [node) xmlquery
    | [node) xmltable
    | [node) function_expression & [node-1) '('
;

r2_flowcontrol_condition:
      (
          [node) condition
        | [node) pls_expr
      )
    & (
          [keyword) 'WHEN'
        | [keyword) 'IF'
        | [keyword) 'ELSIF'
      )
    & node = keyword+1
;

r2_case_expression:
      [node) simple_case_expression[4,27)#
    | [node) searched_case_expression#
    | [node) expr & [node^) simple_case_expression[4,27)#
    | [node) else_clause & [node^) case_expression
    | [node) expr & [node^) else_clause & [node^^) case_expression
    | [node) expr & [node^) searched_case_expression#
    | [node) condition & [node-1) 'WHEN'
;

r2_case_expression_plsql:
      [parent) case_expr
    & (
          [node) case_expr_alt
        | [node) ELSE_expr_opt
        | [node) pls_expr & ([node-1) 'THEN' | [node-1) 'ELSE')
      )
    & parent < node
;

r2_object_type:
      [node) adt_field
    | [node) ',' & [node+1) adt_field
    | [node) body_adt_field
;

r2_body:
      [node) subprg_body
    & [parent) pkg_body
    & parent < node
;

r2_increment_left_margin:
      r2_common
    | r2_flowcontrol_condition
    | r2_case_expression
    | r2_case_expression_plsql
    | r2_object_type
    | r2_body
-> {
    addMargin(tuple.get("node"), indentSpaces);
}

r2_decrement_left_margin:
      ([node) '(' | [node) ')')
          & (
                  [node^) paren_expr_list
                | [node^) fml_part
                | [node^) ty_def
                | [node^) xmlquery
                | [node^) xmltable
            )
    | [node) 'RECORD' & [node^) ty_def
    | [node) 'XMLQUERY' & [node^) xmlquery
    | [node) 'XMLTABLE' & [node^) xmltable
-> {
    addMargin(tuple.get("node"), -1 * indentSpaces);
}

r2_increment_left_margin_for_into_list:
      [node) into_list
    & [into) 'INTO'
    & node = into^
-> {
    var spaces = addMarginByName(tuple.get("node"), "INTO");
    addMargin(tuple.get("into"), -1 * spaces);
}

r2_increment_left_margin_for_select_list:
      [node) select_list
    & [node-1) 'SELECT'
-> {
    addMarginByName(tuple.get("node"), "SELECT");
}

r2_increment_left_margin_for_from:
      [node) from_clause
    & [from) 'FROM'
    & from^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "FROM");
    addMargin(tuple.get("from"), -1 * spaces);
}

r2_increment_left_margin_for_where:
      [node) where_clause
    & [where) 'WHERE'
    & where^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "WHERE");
    addMargin(tuple.get("where"), -1 * spaces);
}

r2_increment_left_margin_for_connect_by:
      [node) condition
    & [node-2) 'CONNECT'
    & [node-1) 'BY'
-> {
    var spaces = addMarginByName(tuple.get("node"), "CONNECT BY");
}

r2_increment_left_margin_for_start_with:
      [node) condition
    & [node-2) 'START'
    & [node-1) 'WITH'
-> {
    var spaces = addMarginByName(tuple.get("node"), "START WITH");
}

r2_increment_left_margin_for_group_by:
      [node) group_by_clause
    & [group) 'GROUP'
    & group^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "GROUP BY");
    addMargin(tuple.get("group"), -1 * spaces);
}

r2_increment_left_margin_for_having:
      [node) having_clause
    & [having) 'HAVING'
    & having^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "HAVING");
    addMargin(tuple.get("having"), -1 * spaces);
}

r2_increment_left_margin_for_order_by:
      [node) order_by_clause
    & [order) 'ORDER'
    & order^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "ORDER BY");
    addMargin(tuple.get("order"), -1 * spaces);
}

r2_increment_left_margin_for_update_set:
      [node) update_set_clause
    & [set) 'SET'
    & set^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "SET");
    addMargin(tuple.get("set"), -1 * spaces);
}

r2_subquery:
      [node) subquery
    & [from) from_clause
    & node < from
;

r2_decrement_left_margin_for_subquery:
    r2_subquery
-> {
    var node = tuple.get("node");
    var from = tuple.get("from")
    if (!getIndent(node.from).contains("\n")
        && getIndent(from.from).contains("\n")
        && target.getSrc().get(new Integer(node.from-1)).content == '(')
    {
        addMargin(node, -1 * indentSpaces);
    }
}

r2_increment_left_margin_for_assoc_arg_value:
      [name) sim_expr
    & [name+1) '='
    & [name+2) '>'
    & [value) expr
    & [value^) assoc_arg
    & value = name+3
-> {
    var name = tuple.get("name");
    var value = tuple.get("value");
    var nameContent = getLastLine(getContent(name.from, value.from));
    var increment = nameContent.length;
    addMargin(value, increment);
}

r2_increment_left_margin_for_assignment:
     [parent) assignment_stmt
   & [node-2) ':'
   & [node-1) '='
   & [node) pls_expr
   & node^ = parent
-> {
    var node = tuple.get("node");
    var parent = tuple.get("parent");
    var parentCol = getColumnWithoutFirstIndent(parent.from);
    var nodeCol = getColumnWithoutFirstIndent(node.from);
    if (!getIndent(node.from).contains("\n")) {
        addMargin(node, nodeCol-parentCol);
    } else {
        addMargin(node, indentSpaces);
    }
}

r2_indent_nodes:
    [runOnce) sql_statements
-> {
    var it = leftMargin.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var margin = leftMargin.get(key);
        var value = newlinePositions.get(key);
        var spaces = value.length()-value.lastIndexOf("\n")-1; // 0 = first column
        var comma = 0;
        var spacesAfterComma = 0;
        if (key < target.getSrc().size()) {
            if (target.getSrc().get(key).content == ",") {
                comma = 1;
                if (spaceAfterCommas) {
                   comma += 1;
                }
            }
        }
        if (useFullLeftMargin(key)) {
            struct.putNewline(key, value.substr(0, value.lastIndexOf("\n")+1) + getSpaces(margin-comma));
            logger.fine(struct.getClass(), "r2_indent_nodes: set calculated margin of " + (margin-comma) + " spaces at " + key);
        } else {
            if (margin-spaces-comma > 0) {
                for (var i=0; i<margin-spaces-comma; i++) {
                    value+=" ";
                }
                struct.putNewline(key, value);
                logger.fine(struct.getClass(), "r2_indent_nodes: add " + (margin-spaces-comma) + " spaces at " + key);
            }
        }
    }
}

r2_fix_indent_for_subquery:
   r2_subquery
-> {
    var node = tuple.get("node");
    var from = tuple.get("from")
    if (!getIndent(node.from).contains("\n")
        && getIndent(from.from).contains("\n")
        && target.getSrc().get(new Integer(node.from-1)).content == '(')
    {
        addIndent(node, getColumn(node.from) - getColumn(from.from));
        logger.fine(struct.getClass(), "r2_fix_indent_for_subquery: at " + node.from);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R7: SQL keywords are right aligned within a SQL command.
-- --------------------------------------------------------------------------------------------------------------------

r7_select:
      ([parent) select | [parent) subquery | [parent) query_block)
    & (
          [keyword) 'DISTINCT'
        | [keyword) 'UNIQUE'
        | [keyword) 'ALL'
        | [keyword) 'BULK'
        | [keyword) 'INTO'
        | [keyword) 'FROM'
        | [keyword) 'INNER'
        | [keyword) 'CROSS'
        | [keyword) 'NATURAL'
        | [keyword) 'FULL'
        | [keyword) 'LEFT'
        | [keyword) 'RIGHT'
        | [keyword) 'JOIN'
        | [keyword) 'PARTITION'
        | [keyword) 'BY'
        | [keyword) 'ON'
        | [keyword) 'USING'
        | [keyword) 'OUTER'
        | [keyword) 'APPLY'
        | [keyword) 'WHERE'
        | [keyword) 'CONNECT'
        | [keyword) 'START'
        | [keyword) 'GROUP'
        | [keyword) 'HAVING'
        | [keyword) 'ORDER'
      )
    & parent < keyword
;

r7_insert:
      [parent) insert
    & (
          [keyword) 'ALL'
        | [keyword) 'FIRST'
        | [keyword) 'WHEN'
        | [keyword) 'THEN'
        | [keyword) 'ELSE'
        | [keyword) 'INTO'
        | [keyword) 'VALUES'
        | [keyword) 'RETURN'
        | [keyword) 'RETURNING'
        | [keyword) 'LOG'
        | [keyword) 'REJECT'
        | [keyword) 'SELECT' & ![keyword^^-1) '('
      )
    & parent < keyword
;

r7_update:
      [parent) update
    & (
          [keyword) 'SET'
        | [keyword) 'WHERE'
        | [keyword) 'RETURNING'
        | [keyword) 'INTO'
      )
    & parent < keyword
;

r7_delete:
      [parent) delete
    & (
          [keyword) 'FROM'
        | [keyword) 'WHERE'
        | [keyword) 'RETURNING'
        | [keyword) 'INTO'
      )
    & parent < keyword
;

r7_right_align_keywords:
      r7_select
    | r7_insert
    | r7_update
    | r7_delete
-> {
    if (!breaksAfterSelect) {
        var keyword = tuple.get("keyword");
        var parent = tuple.get("parent");
        var parentIndent = System.lineSeparator() + getSpaces(getColumn(parent.from));
        var parentLength = target.getSrc().get(parent.from).content.length();
        if (target.getSrc().get(parent.from).content.toLowerCase() == "with") {
            parentLength = 6;
        }
        if (getIndent(keyword.from).contains("\n")) {
            if (alignRight) {
                var content = target.getSrc().get(keyword.from).content;
                var missingSpaces = parentLength - target.getSrc().get(keyword.from).content.length();
                var keywordIndent = parentIndent + getSpaces(missingSpaces);
                struct.putNewline(keyword.from, keywordIndent);
                logger.fine(struct.getClass(), "r7_right_align_keywords: align <" + content + "> at " + keyword.from);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A11: Align parameter names.
-- --------------------------------------------------------------------------------------------------------------------

a11_declarations:
    [runOnce) sql_statements
-> {
    var paramNames = new HashMap();
}

a11_find_param_names:
      [scope) fml_part
    & ([parenOrComma) '(' | [parenOrComma) ',')
    & [node) decl_id
    & scope < node
    & parenOrComma = node^-1
-> {
    var node = tuple.get("node");
    var scope = tuple.get("scope");
    if (firstParameterOnLine(node.from, scope.from)) {
        if (struct.breaksBeforeComma()) {
            var parenOrComma = tuple.get("parenOrComma");
            var parenOrCommaContent = target.getSrc().get(parenOrComma.from).content;
            if (parenOrCommaContent == ',') {
                tuple.put("aligner", parenOrComma);
            } else {
                tuple.put("aligner", node);
            }
        } else {
            tuple.put("aligner", node);
        }
        removeLeadingSpaces(tuple.get("aligner").from);
        addTupleToMap(tuple, "scope", paramNames);
    }
}

o11_align_param_names:
    [runOnce) sql_statements
-> {
    align(paramNames, "aligner", null, "a11_find_param_names");
    fixIndentOfLeadingCommas(paramNames, "aligner", "a11_find_param_names");
}

-- --------------------------------------------------------------------------------------------------------------------
-- A10: Align parameter modes.
-- --------------------------------------------------------------------------------------------------------------------

a10_declarations:
    [runOnce) sql_statements
-> {
    var paramModes = new HashMap();
}

a10_find_param_modes:
      [scope) fml_part
    & [name) decl_id
    & [node) mode
    & scope < node
    & name = node-1
-> {
    if (alignTypeDecl) {
        var name = tuple.get("name");
        var scope = tuple.get("scope");
        if (firstParameterOnLine(name.from, scope.from)) {
            var node = tuple.get("node");
            addTupleToMap(tuple, "scope", paramModes);
        }
    }
}

a10_align_param_modes:
    [runOnce) sql_statements
-> {
    align(paramModes, "node", null, "a10_align_param_modes");
}

-- --------------------------------------------------------------------------------------------------------------------
-- O8: Alignment: Type Declarations. Options: true; false. (alignTypeDecl).
-- --------------------------------------------------------------------------------------------------------------------

o8_declarations:
    [runOnce) sql_statements
-> {
    var datatypes = new HashMap();
}

o8_variables:
      [scope) decl_list
    & [name) decl_id
    & [parent) basic_d
    & name = node-1
    & scope < name^
    & parent = name^
    & [parent = [name
;

o8_records:
      [scope) ty_def
    & [node-1) identifier
    & [node^) field
    & scope < node^
;

o8_find_type_declarations:
      o8_variables
    | o8_records
-> {
    if (alignTypeDecl) {
        var node = tuple.get("node");
        addTupleToMap(tuple, "scope", datatypes);
    }
}

o8_find_parameter_declarations:
      [scope) fml_part
    & [name) decl_id
    & [node) unconstrained_type
    & scope < node
    & (name = node-1 | name = node-2)
-> {
    if (alignTypeDecl) {
        var name = tuple.get("name");
        var scope = tuple.get("scope");
        if (firstParameterOnLine(name.from, scope.from)) {
            var node = tuple.get("node");
            addTupleToMap(tuple, "scope", datatypes);
        }
    }
}

o8_align_type_declarations:
    [runOnce) sql_statements
-> {
    align(datatypes, "node", null, "o8_align_type_declarations");
}

-- --------------------------------------------------------------------------------------------------------------------
-- O4: Alignment: Assignment Operator :=. Options: true; false. (alignAssignments).
-- --------------------------------------------------------------------------------------------------------------------

o4_declarations:
    [runOnce) sql_statements
-> {
    var assignments = new HashMap();
    var assignmentsWithValue = new HashMap();
}

o4_declare_section:
      [scope) decl_list
    & [node) default_expr_opt
    & scope < node
;

o4_function:
      [scope) fml_part
    & [node) default_expr_opt
    & scope < node
;

o4_find_assignments:
      o4_declare_section
    | o4_function
-> {
    if (alignAssignments) {
        var scope = tuple.get("scope");
        if (containsLineBreak(scope)) {
            addTupleToMap(tuple, "scope", assignments);
        }
    }
}

o4_find_body_assignments:
      ([scope) if_stmt | [scope) case_stmt | [scope) seq_of_stmts)
    & [node) ':'
    & [node+1) '='
    & [value) pls_expr
    & scope < node
    & value = node+2
-> {
    if (alignAssignments) {
        var scope = tuple.get("scope");
        var value = tuple.get("value")
        if (getIndent(value.from).contains("\n")) {
            tuple.remove("value");
        }
        addTupleToMap(tuple, "scope", assignmentsWithValue);
    }
}

o4_align_assignments:
    [runOnce) sql_statements
-> {
    align(assignments, "node", null, "o4_align_assignments");
    align(assignmentsWithValue, "node", "value", "o4_align_assignments");
}

-- --------------------------------------------------------------------------------------------------------------------
-- O5: Alignment: Column and Table aliases. Options: true; false. (alignTabColAliases).
-- --------------------------------------------------------------------------------------------------------------------

o5_declarations:
    [runOnce) sql_statements
-> {
    var selectTermEndsOnNewline = function(node) {
        if (getIndent(node.to).contains("\n")) {
            return true;
        } else {
            var content = target.getSrc().get(node.to).content;
            if (content == ",") {
                if (getIndent(node.to+1).contains("\n")) {
                    return true;
                }
            }
        }
        return false;
    }

    var tableReferenceOnNewline = function (node) {
        var n = target.getRoot().leafAtPos(node.from - 1);
        do {
            n = target.getRoot().leafAtPos(n.from - 1);
            if (getIndent(n.from).contains("\n")) {
                return true;
            }
        } while (!n.contains("'FROM'") && !n.contains("query_table_expression"))
        return false;
    }

    var aliases = new HashMap();
}

o5_column_alias:
      [scope) select_clause
    & [node) as_alias
    & scope < node
-> {
    if (alignTabColAliases) {
        var node = tuple.get("node");
        if (selectTermEndsOnNewline(node)) {
            addTupleToMap(tuple, "scope", aliases);
        }
    }
}

o5_table_alias:
      [scope) from_clause
    & [node) identifier
    & [node-1) query_table_expression
    & scope < node
-> {
    if (alignTabColAliases) {
        var node = tuple.get("node");
        if (tableReferenceOnNewline(node)) {
            addTupleToMap(tuple, "scope", aliases);
        }
    }
}

o5_align_aliases:
    [runOnce) sql_statements
-> {
    align(aliases, "node", null, "o5_align_aliases");
}

-- --------------------------------------------------------------------------------------------------------------------
-- O7: Alignment: Equality Predicate =. Options: true; false. (alignEquality).
-- --------------------------------------------------------------------------------------------------------------------

o7_declarations:
    [runOnce) sql_statements
-> {
    /* returns true if there is no other equality sign on the line */
    var firstEqualitySignOnLine = function(nodeFrom) {
        for (var i=nodeFrom-1; i>=0 && !getIndent(i).contains("\n"); i=i-1) {
            var content = target.getSrc().get(i).content;
            if (content == "=") {
                return false;
            }
        }
        return true;
    }

    var equalitySigns = new HashMap();
}

o7_find_equality_predicates:
      [scope) condition
    & ![scope^) condition
    & [node) '='
    & [value) expr
    & scope < node
    & value = node+1
-> {
    if (alignEquality) {
        var node = tuple.get("node");
        if (firstEqualitySignOnLine(node.from)) {
            addTupleToMap(tuple, "scope", equalitySigns);
        }
    }
}

o7_align_equality_predicates:
    [runOnce) sql_statements
-> {
    align(equalitySigns, "node", "value", "o7_align_equality_predicates");
}

-- --------------------------------------------------------------------------------------------------------------------
-- R6: Call parameters aligned, operators aligned, values aligned.
-- --------------------------------------------------------------------------------------------------------------------

r6_declarations:
    [runOnce) sql_statements
-> {
    var assocNames = new HashMap();
    var assocValues = new HashMap();
}

r6_find_names:
      [scope) paren_expr_list
    & [node+1) arg
    & scope < node
-> {
    var scope = tuple.get("scope");
    if (containsLineBreak(scope)) {
        var parenOrComma = tuple.get("node");
        var arg = tuple.get("node+1")
        var parenOrCommaContent = target.getSrc().get(parenOrComma.from).content;
        if (parenOrCommaContent == '('
                || getIndent(parenOrComma.from).contains("\n")
                || getIndent(arg.from).contains("\n"))
        {
            if (struct.breaksBeforeComma()) {
                if (parenOrCommaContent == ',') {
                    tuple.put("aligner", parenOrComma);
                } else {
                    tuple.put("aligner", arg);
                }
            } else {
                tuple.put("aligner", arg);
            }
            removeLeadingSpaces(tuple.get("aligner").from);
            addTupleToMap(tuple, "scope", assocNames);
        }
    }
}

r6_align_names:
    [runOnce) sql_statements
-> {
    align(assocNames, "aligner", null, "r6_align_names");
    fixIndentOfLeadingCommas(assocNames, "aligner", "r6_align_names");
}

r6_find_values:
      [scope) paren_expr_list
    & [arg) assoc_arg
    & [node) '='
    & [greater) '>'
    & [value) expr
    & arg = node^
    & scope < node
    & value = greater+1
    & node = greater-1
-> {
    if (alignNamedArgs) {
        var scope = tuple.get("scope");
        if (containsLineBreak(scope)) {
            addTupleToMap(tuple, "scope", assocValues);
        }
    }
}

r6_align_values:
    [runOnce) sql_statements
-> {
    align(assocValues, "node", "value", "r6_align_values");
}

-- --------------------------------------------------------------------------------------------------------------------
-- A9: Align xmltable columns.
-- --------------------------------------------------------------------------------------------------------------------

a9_declarations:
    [runOnce) sql_statements
-> {
    var xmlTableColumns = new HashMap();
}

a9_find_columns:
      [scope) XMLTABLE_options[19,37)
    & [node) XML_table_column
    & [comma) ','
    & scope < node
    & node = comma+1
-> {
    var scope = tuple.get("scope");
    if (struct.breaksBeforeComma()) {
        tuple.put("aligner", tuple.get("comma"));
    } else {
        tuple.put("aligner", tuple.get("node"));
    }
    struct.putNewline(tuple.get("aligner").from, System.lineSeparator());
    addTupleToMap(tuple, "scope", xmlTableColumns);
}

a9_align_xmltable_columns:
    [runOnce) sql_statements
-> {
    var it = xmlTableColumns.keySet().iterator();
    while (it.hasNext()) {
        var scope = it.next();
        struct.putNewline(new Integer(scope.from+1), " ");
        var pos = getColumn(scope.from+1);
        var list = xmlTableColumns.get(scope);
        alignAtPos(pos, list, "aligner", null, "a9_align_xmltable_columns");
        fixIndentOfLeadingCommas(xmlTableColumns, "aligner", "a9_align_xmltable_columns");
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A4: Split long lines.
-- --------------------------------------------------------------------------------------------------------------------

-- This must run at the very end to override SQLDev's default behavior.
-- SQL Developer adds a line break after the token that exceeds max char line width.
-- This behaviour is not wanted, since the indentation is not added.
-- This piece of code addresses this issue. It adds a new line with the indentation of the current line.
-- No additional indentation is added to make this work for long argument lists as well
-- (indentation might not be reduced on subsequent formatter calls).
-- It's important to note that the lines may be a bit longer than the configured max char line width.
-- That's expected and matches the SQLDev logic. It ensures also that corner cases can be handled by
-- this code (e.g. string tokens > max char line width).
-- Due to this simple algorithm, it is expected that a subsequent formatter call will produce a different result.

a4_add_line_breaks_with_indent:
    [runOnce) sql_statements
-> {
    var pos = 0;
    var indent = System.lineSeparator(); /* handle first line */
    for (var key=0; key<target.getSrc().size(); key++) {
        if (pos > maxCharLineSize && target.getSrc().get(key).content.length() > 1 && !getIndent(key).contains("\n")) {
            struct.putNewline(key, indent);
            pos = indent.length() + target.getSrc().get(key).content.length();
            logger.fine(struct.getClass(), "a4_add_line_breaks_with_indent: at " + key);
        } else {
            var value = getIndent(key);
            if (value.contains("\n")) {
                pos = getNumCharsAfterNewLine(value);
                indent = System.lineSeparator() + getSpaces(pos);
            } else {
                pos += getNumCharsAfterNewLine(value);
            }
            var content = target.getSrc().get(key).content;
            var contentLength = content.length;
            var nlpos = content.lastIndexOf("\n") + 1;
            if (nlpos > 0) {
                contentLength -= nlpos;
            }
            pos += contentLength;
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
--  D2: Log time spent in this program.
-- --------------------------------------------------------------------------------------------------------------------

d2_log_time:
    [runOnce) sql_statements
-> {
    var endTime = (new Date()).getTime();
    logger.info(struct.getClass(), "d2_log_time: formatted " + tokens.length + " tokens and "
        + target.getRoot().to + " nodes in "
        + ((endTime - startTime) / 1000) + " seconds.");
}
