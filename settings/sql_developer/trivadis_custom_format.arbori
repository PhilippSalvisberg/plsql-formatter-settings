/*
 * Copyright 2021 Philipp Salvisberg <philipp.salvisberg@trivadis.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Lightweight Formatter for SQL Developer and SQLcl
 * The idea is to keep the code formatted "as is" and apply chosen formatting rules only.
 *
 * The Arbori program is processed from top to bottom in a single file.
 * No include files are used. The reason is, that SQLDev 20.4.1
 * cannot include files based on relative paths and absolute paths are not feasible.
 *
 * To structure the Arbori program the concept of "phases" and "sections" are used.
 * A phase consists of one ore more sections.
 * A section consists of one or more Arbori queries.
 *
 * The following two phases are defined:
 *
 * - Phase 1 - Initialization and preprocessing.
 * - Phase 2 - Processing section by section. The processing order is important.
 *
 * The start of a phase is visualized by a comment series like this
 *
 * -- ================================
 * -- Phase <PhaseNumber> - <Comment>.
 * -- ================================
 *
 * The sections have the following format <Category><SectionNumber>.
 * The next table explains the meaning of a category:
 *
 * Cat.  Meaning                 Description
 * ----  ----------------------  ------------------------------------------------------
 * I     Initialization Section  Identifies a section in an initialization phase.
 * O     SQLDev Option           Implements a SQL Developer option (Advanced Format).
 * R     Trivadis Rule           Implements a Trivadis PL/SQL & SQL Guideline.
 * A     Add-on Section/Rule     Additional formatting rule, that is not based on
 *                               the Trivadis PL/SQL & SQL Guidelines. Nonetheless it's
 *                               considered important to improve the formatting result.
 *
 * The SectionNumber identifies a section within a category.
 *
 * The start of a section is visualized by a comment series like this
 *
 * -- -------------------------------------
 * -- <Category><SectionNumber>: <Comment>.
 * -- -------------------------------------
 *
 * The lightweight formatter honors most of the SQLDev options. However, the following options
 * are ignored, have limitations or are considered only partially:
 *
 * - Indentation: indent with. Options: Tab; Spaces. (useTab).
 *   The formatter supports only indentation with spaces. Spaces are used even if "Tab" is configured.
 *   Using tab would lead to various issues in combination with other settings (e.g. leading commas).
 *
 * - Line Breaks: Commas per line in procedures. Options: Integer value. (breaksProcArgs).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * - Line Breaks: For compound_condition parenthesis. Options: true; false. (breakParenCondition).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * - Line Breaks: After statements. Options: Double break; Single break; Preserve original. (extraLinesAfterSignificantStatements).
 *   The formatter ignores this configuration.
 *   The idea of the lightweight formatter is to leave this decision to the developer.
 *
 * The following SQL options are honored, but not implemented by this Arbori program.
 * They are implemented by SQLDev's oracle.dbtools.app.Format class. As a result the behavior cannot be overridden.
 *
 * - Format:
 *   - Convert Case Only. Options: true, false. (adjustCaseOnly).
 * - Advanced Format:
 *   - General: Keywords case. Options: UPPER; lower; Init cap; Keep unchanged. (kwCase).
 *   - General: Identifiers case. Options: UPPER; lower; Init cap; Keep unchanged. (idCase).
 *   - General: 1-line long comments. Options: Keep unchanged; Wrap multiline; Wrap singleline. (singleLineComments).
 *   - Line Breaks: Before line comments. Options: true; false. (forceLinebreaksBeforeComment).
 */

-- ====================================================================================================================
-- Phase 1 - Initialization and pre-processing.
-- ====================================================================================================================

-- --------------------------------------------------------------------------------------------------------------------
-- I1: Minimal Arbori program (expected by the formatter).
-- --------------------------------------------------------------------------------------------------------------------

-- Callback function to ensure numeric literals are formatted correctly (without whitespaces)
dontFormatNode:
    [node) numeric_literal
->
;

-- ":indentCondtions" must be used, otherwise the Arbori program will be considered invalid and the default is used.
-- This rule is never called, hence it does not matter what node is selected.
-- However, I chose to use "identifier" to avoid an Arbori warning.
dummy:
    :indentConditions & [node) identifier
;

-- "skipWhitespaceBeforeNode" must be defined, otherwise the Arbori program will be considered invalid and the default is used.
skipWhiteSpaceBeforeNode:
  [runOnce) sql_statements
-> {
    var doNotCallCallbackFunction;
}

-- analytic functions, to be treated as keywords
"analytics":
      [identifier) identifier
    & [call) analytic_function
    & [call = [identifier
;

-- all identifiers
"ids":
    [identifier) identifier
;

-- Callback function to reduce the list of keywords by the identifiers provided here
identifiers:
    "ids" - "analytics"
->
;

-- --------------------------------------------------------------------------------------------------------------------
-- I2: Globals.
-- --------------------------------------------------------------------------------------------------------------------

-- Global variables, which are likely to be used in more than one Arbori query/action
define_global_variables:
    [runOnce) sql_statements
-> {
    // Java classes
    var ArrayList = Java.type('java.util.ArrayList');
    var Format = Java.type('oracle.dbtools.app.Format');
    var HashMap = Java.type('java.util.HashMap');
    var HashSet = Java.type('java.util.HashSet');
    var Integer = Java.type('java.lang.Integer');
    var LexerToken = Java.type('oracle.dbtools.parser.LexerToken');
    var logger = Java.type('oracle.dbtools.util.Logger');
    var Substitutions = Java.type('oracle.dbtools.parser.Substitutions');
    var System = Java.type('java.lang.System');
    var Token = Java.type('oracle.dbtools.parser.Token');

    // use reflection to access hidden field newlinePositions
    var newlinePositionsField = Format.class.getDeclaredField("newlinePositions");
    newlinePositionsField.setAccessible(true);
    var newlinePositions = newlinePositionsField.get(struct);

    // get option for "Indentation: Indent spaces" (number of spaces for a single indentation)
    var indentSpaces = struct.options.get("identSpaces");

    // get option for "Line Breaks: Max char line width"
    var maxCharLineSize = struct.options.get("maxCharLineSize");

    // get option for "Line Breaks: SELECT/FROM/WHERE"
    var breaksAfterSelect = struct.options.get("breaksAfterSelect");

    // get option for "Alignment: Column and Table aliases"
    var alignTabColAliases = struct.options.get("alignTabColAliases");

    // get option for "Alignment: Assignment Operator :="
    var alignAssignments = struct.options.get("alignAssignments");

    // get option for "Alignment: Named Argument Separator =>"
    var alignNamedArgs = struct.options.get("alignNamedArgs");

    // get option for "Alignment: Right-align query keywords"
    var alignRight = struct.options.get("alignRight");

    // get option for "White Space: Around operators"
    var spaceAroundOperators = struct.options.get("spaceAroundOperators");

    // get option for "Whitespace: Around parenthesis"
    var spaceAroundBrackets = struct.options.get("spaceAroundBrackets");

    // lexer tokens including hidden tokens (LINE_COMMENT, COMMENT, WS, MACRO_SKIP, SQLPLUSLINECONTINUE_SKIP)
    // are relevant to find comments between tokens. These variables are populated in
    // keepSignificantWhitespaceBeforeLeafNodes
    var tokens = null;
    var mapParserPosToLexerPos = new HashMap();
}

-- Global functions, which are likely to be used in more than one Arbory action
define_global_functions:
    [runOnce) sql_statements
-> {
    /* return a string with the requested number of spaces */
    function getSpaces(numberOfSpaces) {
        var result = "";
        for (var i=0; i<numberOfSpaces; i++) {
            result += " ";
        }
        return result;
    }

    /* return the indentation at a node position, converts the default null to a single space */
    function getIndent(nodeFrom) {
        var indent = newlinePositions.get(new Integer(nodeFrom));
        if (indent == null) {
            return " ";
        }
        return indent;
    }

    /* returns the indentation without leading new lines from a string */
    function getNumCharsAfterNewLine(indent) {
        if (indent.contains("\n")) {
            return indent.length() - indent.lastIndexOf("\n") - 1;
        }
        return indent.length();
    }

    /* returns the leading new lines from a node position (without trailing spaces) */
    function getLeadingNewLines(nodeFrom) {
        var startPos=nodeFrom;
        var indent = getIndent(startPos);
        if (indent.contains("\n")) {
            return indent.substring(0, indent.lastIndexOf("\n") + 1);
        }
        return "";
    }

    /* returns the column of a node position, considers all preceding nodes */
    function getColumn(nodeFrom) {
        var startPos=nodeFrom;
        var col=getNumCharsAfterNewLine(getIndent(startPos));
        var indent = getIndent(startPos);
        for (var i=startPos-1; i>=0 && !indent.contains("\n"); i=i-1) {
            col += target.getSrc().get(i).content.length();
            var indent = getIndent(i);
            col += getNumCharsAfterNewLine(indent);
        }
        return col;
    }

    /* returns true if a node or one of its children contains an indentation with a new line character */
    function containsLineBreak(node) {
        for (var i = node.from; i < node.to; i++) {
            var value = getIndent(i);
            if (value.contains("\n")) {
                return true;
            }
        }
    }

    /* returns true if single-line or multi-line comments exists between two node positions */
    function hasCommentsBetweenPos(startPos, endPos) {
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                return true;
            }
        }
        return false;
    }

    /* returns the the last comment (sl or ml) between two node positions */
    function getLastCommentBetweenPos(startPos, endPos) {
        var comment = "";
        tokenStartPos = mapParserPosToLexerPos.get(new Integer(startPos));
        tokenEndPos = mapParserPosToLexerPos.get(new Integer(endPos));
        for (var i = tokenStartPos; i < tokenEndPos; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                comment = tokens[i].content;
            }
        }
        return comment;
    }

    /* returns the maximum column of nodes in an array list of tuples */
    var getMaxColumn = function(list, nodeName) {
        var maxCol = 0;
        for (var i=0; i < list.length; i++) {
            var node = list.get(i).get(nodeName)
            var col = getColumn(node.from);
            if (col > maxCol) {
                maxCol = col;
            }
        }
        return maxCol;
    }

    /* adds a tuple to a map indexed by scope */
    var addTupleToMap = function (tuple, scopeNodeName, map) {
        var scope = tuple.get(scopeNodeName);
        var list = map.get(scope);
        if (list == null) {
            list = new ArrayList();
        }
        list.add(tuple);
        map.put(scope, list);
    }

    /* aligns all nodes per scope */
    var align = function(map, nodeName, logText) {
        var it = map.keySet().iterator();
        while (it.hasNext()) {
            var scope = it.next();
            var list = map.get(scope);
            var maxCol = getMaxColumn(list, nodeName);
            for (var i=0; i<list.length; i++) {
                var node = list.get(i).get(nodeName);
                var indent = getIndent(node.from);
                var col = getColumn(node.from);
                if (maxCol > col) {
                    indent = indent + getSpaces(maxCol - col);
                    struct.putNewline(node.from, indent);
                    logger.fine(struct.getClass(), logText + ": at " + node.from);
                }
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- I3: Remove duplicate empty lines.
-- --------------------------------------------------------------------------------------------------------------------

-- Replace multiple, consecutive empty lines with one empty line.
-- This code changes the input (target.input) and the lexer tokens (target.src).
-- Therefore this code must run at the beginning of the Arbori program.
max_one_empty_line:
    [runOnce) sql_statements
-> {
    var offOnRanges = [];

    var populateOffOnRanges = function(tokens) {
        var off = -1;
        offOnRanges = [];
        for (var i in tokens) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
                if (tokens[i].content.toLowerCase().contains("@formatter:off") || tokens[i].content.toLowerCase().contains("noformat start")) {
                    off = tokens[i].begin;
                }
                if (off != -1) {
                    if (tokens[i].content.toLowerCase().contains("@formatter:on") || tokens[i].content.toLowerCase().contains("noformat end")) {
                        offOnRanges.push([off, tokens[i].end]);
                        off = -1;
                    }
                }
            }
        }
    }

    var inOffOnRange = function(pos) {
        for (var x in offOnRanges) {
            if (pos >= offOnRanges[x][0] && pos < offOnRanges[x][1]) {
                return true;
            }
        }
        return false;
    }

    var removeDuplicateEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var firstEOLToken = 0;
        var secondEOLToken = 0;
        var lastEOLToken = 0;
        for (i = 0; i < tokens.length; i++) {
            var type = tokens[i].type;
            if (type == Token.LINE_COMMENT && firstEOLToken == 0) {
                firstEOLToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (firstEOLToken == 0) {
                    firstEOLToken = tokens[i];
                } else if (secondEOLToken == 0) {
                    secondEOLToken = tokens[i];
                } else {
                    lastEOLToken = tokens[i];
                }
                continue;
            }
            if (type != Token.WS) {
                if (lastEOLToken != 0) {
                    if (!inOffOnRange(secondEOLToken.begin)) {
                        substitutions.put(secondEOLToken.begin,lastEOLToken.begin,"");
                    }
                }
                firstEOLToken = 0;
                secondEOLToken = 0;
                lastEOLToken = 0;
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    var removeWSOnEmptyLines = function() {
        var tokens = LexerToken.parse(target.input,true);  // parse with WS symbols
        populateOffOnRanges(tokens);
        var substitutions = new Substitutions(target.input);
        var eolToken = 0
        for (i = 0; i < tokens.length; i++) {
            var type = tokens[i].type;
            if (type != Token.WS) {
                eolToken = 0;
                continue;
            }
            if (eolToken == 0 && (type == Token.LINE_COMMENT || tokens[i].content == "\n")) {
                eolToken = tokens[i];
                continue;
            }
            if (tokens[i].content == "\n") {
                if (eolToken != 0) {
                    if (!inOffOnRange(eolToken.end)) {
                        substitutions.put(eolToken.end,tokens[i].begin,"");
                    }
                }
                eolToken = tokens[i];
            }
        }
        // update source code
        target.input = substitutions.transformInput();
    }

    // replacements
    removeDuplicateEmptyLines();
    removeWSOnEmptyLines();

    // tokens without WS and comments (mimicking default behaviour)
    var Lexer = Java.type('oracle.dbtools.parser.Lexer');
    var defaultTokens = Lexer.parse(target.input);

    // produce a new parse tree based on the updated lexer tokens
    var Parsed = Java.type('oracle.dbtools.parser.Parsed');
    var SqlEarley = Java.type('oracle.dbtools.parser.plsql.SqlEarley')
    var newTarget = new Parsed(target.input, defaultTokens, SqlEarley.getInstance(), Java.to(["sql_statements"], "java.lang.String[]"));

    // update token list based on fixed source code (without WS tokens)
    target.src.clear();
    target.src.addAll(newTarget.src);

    // enable next line to print all node names on the console (e.g. when SQLDev UI shows unnamed nodes)
    // target.root.printTree();
}

-- --------------------------------------------------------------------------------------------------------------------
-- I4: Keep existing whitespace.
-- --------------------------------------------------------------------------------------------------------------------

-- add explicit whitespace before each leaf node, if the whitespace before is not a single space (default)
keep_significant_whitespace_before_leaf_nodes:
    [runOnce) sql_statements
-> {
    tokens = LexerToken.parse(target.input, true);  // include hidden tokens not relevant to build a parse tree
    var hiddenTokenCount = 0;
    var wsBefore = "";
    for (var i in tokens) {
        var type = tokens[i].type;
        // count hidden tokens
        if (type == Token.LINE_COMMENT || type == Token.COMMENT || type == Token.WS ||
            type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP)
        {
            hiddenTokenCount++;
            // concatenate whitespace before a node
            if (type == Token.WS) {
                wsBefore += tokens[i].content;
            } else {
                // ensure that other hidden token are not counted as whitespace
                wsBefore = "";
            }
        } else {
            mapParserPosToLexerPos.put(new Integer(i-hiddenTokenCount), i);
            if (wsBefore != " ") {
                // add collected whitespace before leaf node (actually at the position of the leaf node)
                // add also empty strings to ensure that not a space is added between tokens
                struct.putNewline(i-hiddenTokenCount, wsBefore);
                logger.fine(struct.getClass(), "keepSignificantWhitespaceBeforeLeafNodes: add "
                    + wsBefore.length() + " whitespace at " + (i-hiddenTokenCount));
            }
            wsBefore = "";
        }
    }
}

-- ====================================================================================================================
-- Phase 2 - Processing section by section.
-- ====================================================================================================================

-- --------------------------------------------------------------------------------------------------------------------
-- A1: Do not use tabs.
-- --------------------------------------------------------------------------------------------------------------------

-- replace tabs with the configured indentation (default is 3)
a1_replace_tabs_with_spaces:
    [runOnce) sql_statements
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\t")) {
            struct.putNewline(key, value.replaceAll("\t", indent));
            logger.fine(struct.getClass(), "a1_replace_tabs_with_spaces: at " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A2: Remove trailing spaces.
-- --------------------------------------------------------------------------------------------------------------------

a2_remove_trailing_spaces:
    [runOnce) sql_statements
-> {
    var indent = getSpaces(indentSpaces);
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        // handle Linux and Windows line separators regardless of the OS
        var newValue = value.replaceAll("[ ]+\\n", "\n").replaceAll("[ ]+\\r\\n", "\r\n");
        if (!value.equals(newValue)) {
            struct.putNewline(key, newValue);
            logger.fine(struct.getClass(), "a2_remove_trailing_spaces: at " + key);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A3: Do not format code between @formatter:off and @formatter:on comments.
-- --------------------------------------------------------------------------------------------------------------------

a3_dont_format_off_on_ranges:
    [runOnce) sql_statements
-> {
    var hiddenTokenCount = 0;
    var format = true;
    for (var i in tokens) {
        var type = tokens[i].type;
        if (type == Token.LINE_COMMENT || type == Token.COMMENT) {
            var content = tokens[i].content.toLowerCase();
            if (content.contains("@formatter:off") || content.contains("noformat start")) {
                format = false;
            }
            if (content.contains("@formatter:on") || content.contains("noformat end")) {
                format = true;
            }
            hiddenTokenCount++;
        } else if (type == Token.WS || type == Token.MACRO_SKIP || type == Token.SQLPLUSLINECONTINUE_SKIP) {
            hiddenTokenCount++
        } else {
            /* expected types: QUOTED_STRING, DQUOTED_STRING, BQUOTED_STRING, DIGITS, OPERATION, IDENTIFIER, AUXILIARY, INCOMPLETE */
            if (!format) {
                var pos = new Integer(i-hiddenTokenCount);
                struct.unformattedPositions.add(pos);
                logger.fine(struct.getClass(), "a3_dont_format_off_on_ranges: at " + pos);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O2: White Space: Around operators. Options: true; false. (spaceAroundOperators).
-- --------------------------------------------------------------------------------------------------------------------

o2_whitespace_around_operators:
      [node) '<'
    | [node) '>'
    | [node) '='
    | [node) '!'
    | [node) '~'
    | [node) '^'
    | [node) '+'
    | [node) '-'
    | [node) '*'
    | [node) '/' & ![node-1) block_stmt & ![node-1) create_plsql
    | [node) '|'
    | [node) ':'
-> {
    var node = tuple.get("node");
    var space;
    if (spaceAroundOperators) {
       space = " ";
    } else {
       space = "";
    }
    if (!getIndent(node.from).contains("\n")) {
        struct.putNewline(node.from, space);
        logger.fine(struct.getClass(), "o2_whitespace_around_operators: before at " + node.from);
    }
    if (!getIndent(node.to).contains("\n")) {
        struct.putNewline(node.to, space);
        logger.fine(struct.getClass(), "o2_whitespace_around_operators: after at " + node.to);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O3: White Space: Around parenthesis. Options: Default; Inside; Outside; No space. (spaceAroundBrackets).
-- --------------------------------------------------------------------------------------------------------------------

o3_whitespace_around_open_paren:
     [node) '('
-> {
    var node = tuple.get("node");
    if (spaceAroundBrackets != Format.Space.Default) {
        if (!getIndent(node.from).contains("\n")) {
            var spaceBefore;
            if (spaceAroundBrackets == Format.Space.Inside || spaceAroundBrackets == Format.Space.NoSpace) {
                spaceBefore = "";
            } else {
                spaceBefore = " ";
            }
            struct.putNewline(node.from, spaceBefore);
            logger.fine(struct.getClass(), "o3_whitespace_around_open_paren: <" + spaceBefore + "> before at " + node.from);
        }
    }
    if (!getIndent(node.to).contains("\n")) {
        var spaceAfter;
        if (spaceAroundBrackets ==  Format.Space.Outside || spaceAroundBrackets == Format.Space.NoSpace || spaceAroundBrackets == Format.Space.Default) {
            spaceAfter = "";
        } else {
            spaceAfter = " ";
        }
        struct.putNewline(node.to, spaceAfter);
        logger.fine(struct.getClass(), "o3_whitespace_around_open_paren: <" + spaceAfter + "> after at " + node.to);
    }
}

o3_whitespace_around_close_paren:
   [node) ')'
-> {
    var node = tuple.get("node");
    if (!getIndent(node.from).contains("\n")) {
        var spaceBefore;
        if (spaceAroundBrackets == Format.Space.Outside || spaceAroundBrackets == Format.Space.NoSpace || spaceAroundBrackets == Format.Space.Default) {
            spaceBefore = "";
        } else {
            spaceBefore = " ";
        }
        struct.putNewline(node.from, spaceBefore);
        logger.fine(struct.getClass(), "o3_whitespace_around_close_paren: <" + spaceBefore + "> before at " + node.from);
    }
    if (spaceAroundBrackets != Format.Space.Default) {
        if (!getIndent(node.to).contains("\n")) {
            var spaceAfter;
            if (spaceAroundBrackets ==  Format.Space.Inside || spaceAroundBrackets == Format.Space.NoSpace) {
                spaceAfter = "";
            } else {
                spaceAfter = " ";
            }
            struct.putNewline(node.to, spaceAfter);
            logger.fine(struct.getClass(), "o3_whitespace_around_close_paren: <" + spaceAfter + "> after at " + node.to);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A5: No space before node.
-- --------------------------------------------------------------------------------------------------------------------

a5_semicolon:
    [node) ';'
;

a5_dot:
    [node) '.'
;

a5_concat:
      [node-1) '|'
    & [node) '|'
;

a5_not_equal:
      [node-1) '<' & [node) '>'
    | [node-1) '!' & [node) '='
    | [node-1) '^' & [node) '='
    | [node-1) '~' & [node) '='
;

a5_assignment:
      [node-1) ':'
    & [node) '='
;

a5_greater_equal:
      [node-1) '>'
    & [node) '='
;

a5_less_equal:
      [node-1) '<'
    & [node) '='
;

a5_greater_greater:
      [node-1) '>' & [node) '>'
    | [node) '>' & [node+1) '>'
;

a5_less_less:
      [node-1) '<'
    & [node) '<'
;

a5_param_assoc:
      [node-1) '='
    & [node) '>'
;

a5_percent:
      [node) '%'
;

a5_at:
      [node) '@'
;

a5_slash:
     ([node-1) block_stmt | [node-1) create_plsql)
   & [node) '/'
;

a5_no_space_before:
      a5_semicolon
    | a5_dot
    | a5_concat
    | a5_not_equal
    | a5_assignment
    | a5_greater_equal
    | a5_less_equal
    | a5_greater_greater
    | a5_less_less
    | a5_param_assoc
    | a5_percent
    | a5_at
    | a5_slash
-> {
    var node = tuple.get("node");
    var content = target.getSrc().get(node.from).content;
    if (content == '/') {
        struct.putNewline(node.from, System.lineSeparator());
        logger.fine(struct.getClass(), "a5_no_space_before: <" + content + ">, add line break at " + node.from);
    } else if (content != '.' || !getIndent(node.from).contains("\n")) {
        // support fluent type methods across multiple lines
        struct.putNewline(node.from, "");
        logger.fine(struct.getClass(), "a5_no_space_before: <" + content + "> at " + node.from);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A6: No space after node.
-- --------------------------------------------------------------------------------------------------------------------

a6_dot:
    [node) '.'
;

a6_less_less:
      [node-1) '<'
    & [node) '<'
;

a6_no_space_after:
      a6_dot
    | a6_less_less
-> {
    var node = tuple.get("node");
    struct.putNewline(node.to, "");
    var content = target.getSrc().get(node.from).content;
    logger.fine(struct.getClass(), "a6_no_space_after: <" + content + "> at " + node.to);
}

-- --------------------------------------------------------------------------------------------------------------------
-- A7: One space before node.
-- --------------------------------------------------------------------------------------------------------------------

a7_param_list:
    [node) fml_part
;

a7_as_alias:
    [node) as_alias
;

a7_table_alias:
      [node) identifier
    & [node-1) query_table_expression
;

a7_one_space_before:
      a7_param_list
    | a7_as_alias
    | a7_table_alias
-> {
    var node = tuple.get("node");
    struct.putNewline(node.from, " ");
    var content = target.getSrc().get(node.from).content;
    logger.fine(struct.getClass(), "a7_one_space_before: <" + content + "> at " + node.from);
}

-- --------------------------------------------------------------------------------------------------------------------
-- A8: One space after node.
-- --------------------------------------------------------------------------------------------------------------------

a8_if:
      ![node+1) ';'
    & [node) 'IF'
;

a8_for_identifier:
     [node-1) 'FOR'
   & [node) identifier
;

a8_as:
      [node) 'AS'
    & [node^) as_alias
;

a8_on:
      [node) 'ON'
    & [node^) on_using_condition
;

a8_join:
    [node) 'JOIN'
;

a8_from:
      [node) 'FROM'
    & [node^) from_clause
;

a8_create_or_replace:
      [node) 'CREATE'
    | [node) 'OR' & [node-1) 'CREATE'
    | [node) 'REPLACE' & [node-1) 'OR' & [node-2) 'CREATE'
    | [node) 'PACKAGE'
    | [node) 'BODY'
    | [node) 'VIEW'
    | [node) 'PROCEDURE'
    | [node) 'FUNCTION'
    | [node) 'TYPE' & ![node-1) '%'
;

a8_select_clauses:
      [node) 'SELECT'
    | [node) 'FROM'
    | [node) 'WHERE'
    | [node) 'CONNECT'
    | [node) 'BY'
    | [node) 'START' & [node+1) 'WITH'
    | [node) 'WITH' & [node-1) 'START'
    | [node) 'GROUP'
    | [node) 'HAVING'
    | [node) 'ORDER'
;

a8_one_space_after:
      a8_if
    | a8_for_identifier
    | a8_as
    | a8_on
    | a8_join
    | a8_from
    | a8_create_or_replace
    | a8_select_clauses
-> {
    var node = tuple.get("node");
    struct.putNewline(node.to, " ");
    var content = target.getSrc().get(node.from).content;
    logger.fine(struct.getClass(), "a8_one_space_after: <" + content + "> at " + node.to);
}

-- --------------------------------------------------------------------------------------------------------------------
-- R3: One command per line.
-- R4: Keywords "loop", "else", "elsif", "end", "when" on a new line.
-- --------------------------------------------------------------------------------------------------------------------

r3_stmt_in_first_conditional_compilation_branch:
    [runOnce) sql_statements
-> {
    var posInConditionalBranch = new HashSet();
    var pos = 0;
    var withinFirstBranch = false;
    for (i = 0; i < tokens.length; i++) {
        var type = tokens[i].type
        var content = tokens[i].content.toLowerCase()
        if (type == Token.MACRO_SKIP && content.startsWith("$if ")) {
            withinFirstBranch = true;
            continue;
        }
        if (withinFirstBranch && type == Token.MACRO_SKIP && content.startsWith("$")) {
            withinFirstBranch = false;
            continue;
        }
        if (type != Token.WS && type != Token.MACRO_SKIP && type != Token.COMMENT && type != Token.LINE_COMMENT) {
            if (withinFirstBranch) {
                posInConditionalBranch.add(new Integer(pos));
                logger.fine(struct.getClass(), "r3_stmt_in_first_conditional_compilation_branch: ignore node at " + pos);
            }
            pos++;
        }
    }
}

r3_sqlplus_commands:
    [node) sqlplus_command
;

r3_sql_commands:
    [node) sql_statement
;

r3_plsql_commands:
      [node) subprg_spec
          & ![node^^) create            -- standalone function/procedure
          & ![node-1) member_or_static  -- object type spec
          & ![node^-1) member_or_static -- object type body
          & ![node-1) 'CONSTRUCTOR'     -- object type spec
          & ![node^-1) 'CONSTRUCTOR'    -- object type body
    | [node) basic_decl_item
    | [node) stmt
;

r3_plsql_keywords:
      [node) 'LOOP' & ![node-1) 'END'
    | [node) 'WHEN'
          & ![node^^) exit_stmt
          & ![node^) merge_insert_clause
          & ![node^) merge_update_clause
    | [node) 'BEGIN'
    | [node) 'END'
    | [node) 'ELSIF'
    | [node) 'ELSE'
;

r3_case_expressions:
      [parent) case_expression
    & ([node) 'WHEN' | [node) 'ELSE' | [node) 'END')
    & parent < node
;

r3_commands:
      r3_sqlplus_commands
    | r3_sql_commands
    | r3_plsql_commands
    | (r3_plsql_keywords - r3_case_expressions)
-> {
    var node = tuple.get("node");
    if (!posInConditionalBranch.contains(node.from)) {
        var indent = getIndent(node.from);
        if (!indent.contains("\n")) {
            struct.putNewline(node.from, System.lineSeparator());
            logger.fine(struct.getClass(), "r3_commands: add line break at " + node.from);
        } else {
            /* remove existing indentation, enforce conformity in these cases */
            var newIndent = getLeadingNewLines(node.from);
            struct.putNewline(node.from, newIndent);
            logger.fine(struct.getClass(), "r3_commands: remove indentation at " + node.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O1: Line Breaks: On concatenation. Options: Before; After; No Breaks. (breaksConcat).
-- --------------------------------------------------------------------------------------------------------------------

-- only when expression consists of more than one concatenation (||)
-- add only missing line breaks, use indentation according column position of previous node
o1_concatenation_option:
      (:breaksBeforeConcat | :breaksAfterConcat)
    & ?node+1 = '||'
    & ([parent) arith_expr | [parent) compound_expression)
    & parent << node
-> {
    var parent = tuple.get("parent");
    var countConcat = 0;
    for (var i=parent.from; i<parent.to && countConcat < 4; i++) {
        if (target.getSrc().get(new Integer(i)).content == '|') {
            countConcat++;
        }
    }
    if (countConcat >= 4) {
        var node = tuple.get("node")
        var concat = tuple.get("node+1");
        var indent = System.lineSeparator() + getSpaces(getColumn(node.from));
        if (struct.breaksBeforeConcat()) {
            struct.putNewline(concat.to, " "); // Before and After is not an option
            if (!getIndent(concat.from).contains("\n")) {
                struct.putNewline(concat.from, indent);
                logger.fine(struct.getClass(), "o1_concatenation_option: add line break before at " + concat.from);
            }
        } else {
            struct.putNewline(concat.from, " "); // Before and After is not an option
            if (!getIndent(concat.to).contains("\n")) {
                struct.putNewline(concat.to, indent);
                logger.fine(struct.getClass(), "o1_concatenation_option: add line break after at " + concat.to);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R5: Commas in front of separated elements.
-- --------------------------------------------------------------------------------------------------------------------

-- Considers the following SQLDev settings:
-- - Line Breaks On Comma
--     "Before" enforces a line break before the comma (this is rule 5)
--     "After" enforces line break after the comma
--     "No Breaks" keeps line breaks before/after comma "as is"
-- - White Space After Commas (option for lines starting with a comma)
--     "checked" enforces exactly one space after the comma
--     "unchecked" enforces no space after a comma

r5_get_prefs:
    [runOnce) sql_statements
-> {
    /* boolean true=space, false=no space */
    var spaceAfterCommas = struct.options.get("spaceAfterCommas");
}

r5_commas:
    [node) ','
-> {
    var getIndentAfterComma = function(indent) {
        var plus = 1;
        if (spaceAfterCommas) {
           plus++;
        }
        return indent + getSpaces(plus);
    }

    var getIndentForComma = function(indent) {
        var len = indent.length() - 1;
        if (spaceAfterCommas) {
           len = len - 1;
        }
        var spaces = indent.length()-indent.lastIndexOf("\n")-1;
        if (spaces > len) {
            return indent.substring(0, len);
        } else {
            return indent;
        }
    }

    var removeLeadingSpaces = function(nodeFrom) {
        var indent = getIndent(nodeFrom);
        if (indent.contains("\n")) {
            var pos = 0;
            for (var i=0; i<indent.length(); i++) {
                if (indent.substring(i, i+1) == " ") {
                    pos++;
                } else {
                    break;
                }
            }
            struct.putNewline(nodeFrom, indent.substring(pos));
        } else {
            struct.putNewline(nodeFrom, "");
        }
    }

    var addSpacesAroundComma = function(commaNode) {
        /* always handle space after comma */
        removeLeadingSpaces(commaNode.from);
        removeLeadingSpaces(commaNode.to);
        if (spaceAfterCommas) {
            var indent = getIndent(commaNode.to);
            if (!indent.contains("\n")) {
                struct.putNewline(commaNode.to, " " + indent);
            }
        } else {
            var indentCommaNode = getIndent(commaNode.from);
            var indentNextNode = getIndent(commaNode.to);
            if (!indentCommaNode.contains("\n") && !indentNextNode.contains("\n")) {
                struct.putNewline(commaNode.to, " ");
            }
        }
    }

    var addBreakAfterComma = function(commaNode) {
        var indentCommaNode = getIndent(commaNode.from);
        if (indentCommaNode.contains("\n") && !hasCommentsBetweenPos(commaNode.from-1, commaNode.to)) {
            /* situation: a new line was added before the comma instead of after */
            struct.putNewline(commaNode.to, getIndentAfterComma(indentCommaNode));
            logger.fine(struct.getClass(), "r5_commas: fix indent after comma at " + commaNode.to);
            struct.putNewline(commaNode.from, "");
        }
    }

    var addBreakBeforeComma = function(commaNode) {
        var indentCommaNode = getIndent(commaNode.from);
        if (!indentCommaNode.contains("\n")) {
            var indentNextNode = getIndent(commaNode.to);
            if (indentNextNode.contains("\n")) {
                /* situation: a new line was added after the comma instead of before */
                struct.putNewline(commaNode.from, getIndentForComma(indentNextNode));
                logger.fine(struct.getClass(), "r5_commas: fix indent before comma at " + commaNode.from);
                if (!hasCommentsBetweenPos(commaNode.from-1, commaNode.to)) {
                    /* remove all whitespace for node */
                    struct.putNewline(commaNode.to, "");
                } else {
                    var comment = getLastCommentBetweenPos(commaNode.from-1, commaNode.to);
                    if (comment.startsWith("--")) {
                       /* we must not remove the newline after a single-line comment */
                    } else {
                       /* removing newline after multi-line comment is wanted, but does not work in SQLDev 20.4.1, it would remove indentation only but keep the newline */
                       logger.fine(struct.getClass(), "r5_commas: SQLDev 20.4.1 bug: new line after a multi-line-comment cannot be set at " + commaNode.from);
                    }
                }
            }
        }
    }

    var node = tuple.get("node");
    if (struct.breaksAfterComma()) {
        addBreakAfterComma(node);
    }
    if (struct.breaksBeforeComma()) {
        addBreakBeforeComma(node);
    }
    addSpacesAroundComma(node);
}

-- --------------------------------------------------------------------------------------------------------------------
-- R2: 3 space indention.
-- --------------------------------------------------------------------------------------------------------------------

-- Determine the left margin for each position managed in newlinePositions with a newline char ("\n") and then
-- ensure that the indentation is >= the this left margin, by adding missing spaces.
-- This code must be executed after missing line breaks have been added.

r2_init_left_margin:
    [runOnce) sql_statements
-> {
    /* left margin is expressed in number of spaces. */
    var leftMargin = new HashMap();
    var it = newlinePositions.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var value = newlinePositions.get(key);
        if (value.contains("\n")) {
            leftMargin.put(key, new Integer(0));
        }
    }

    /* increase the left margin by increaseBy for parent and all its descendants, but only for leaf nodes to avoid duplicate indentation */
    var addMargin = function(parent, increaseBy) {
        var descendants = parent.descendants();
        for (var i = 0, len = descendants.length; i < len; i++) {
            var node = descendants.get(i);
            var margin = leftMargin.get(node.from);
            if (margin != null) {
                if (node.children().size() == 0) {
                    leftMargin.put(node.from, new Integer(margin+increaseBy));
                }
            }
        }
    }

    /* returns the first word within a string */
    var getFirstWord = function(text) {
        var i = text.indexOf(" ");
        if (i == -1) {
            return text;
        } else {
            return text.substr(0, i);
        }
    }

    /* increase left margin by keyword and SQLDev settings */
    var addMarginByName = function(parent, name) {
        var spaces;
        if (breaksAfterSelect) {
            spaces = 3;
        } else if (alignRight) {
            var firstWord = getFirstWord(name);
            if (firstWord.length > 6) {
                spaces = firstWord.length;
            } else {
                spaces = 6;
            }
            spaces = spaces + name.length - firstWord.length + 1;
        } else {
            spaces = name.length + 1;
        }
        addMargin(parent, spaces);
        return spaces;
    }

    /* Use the calculated left margin for this node? */
    var useFullLeftMargin = function(nodeFrom) {
        var supportedSymbols = ["select"/*, "insert", "update", "delete", "merge", "block_stmt"*/]
        var node = target.getRoot().leafAtPos(nodeFrom);
        while (node != null) {
            for (var i=0; i < supportedSymbols.length; i++) {
                if (node.contains(supportedSymbols[i])) {
                    return true;
                }
            }
            node = node.parent();
        }
        return false;
    }
}

r2_common:
      [node) basic_d
    | [node) full_cursor_body
    | [node) stmt
    | [node) pls_expr & [node-2) ':' & [node-1) '='
    | [node) case_stmt_alt
    | [node) else_clause_opt & [node^) case_stmt
    | [node) select & [node^) full_cursor_body
    | [node) excptn_handler
    | [node) subquery_factoring_clause
    | [node) subquery & ([node-1) '(' | [node-1) 'FOR')
    | [node) ty_def
    | [node) fml_part
    | [node) paren_expr_list
    | [node) "expr_list" & [node-1) '('
    | [node) xmlquery
    | [node) xmltable
;

r2_case_expression:
      [node) simple_case_expression[4,27)#
    | [node) searched_case_expression#
    | [node) expr & [node^) simple_case_expression[4,27)#
    | [node) else_clause & [node^) case_expression
    | [node) expr & [node^) else_clause & [node^^) case_expression
    | [node) expr & [node^) searched_case_expression#
;

r2_object_type:
      [node) adt_field
    | [node) ',' & [node+1) adt_field
    | [node) body_adt_field
;

r2_body:
      [node) subprg_body
    & [parent) pkg_body
    & parent < node
;

r2_increment_left_margin:
      r2_common
    | r2_case_expression
    | r2_object_type
    | r2_body
-> {
    addMargin(tuple.get("node"), indentSpaces);
}

r2_decrement_left_margin:
      ([node) '(' | [node) ')')
          & (
                  [node^) paren_expr_list
                | [node^) fml_part
                | [node^) ty_def
                | [node^) xmlquery
                | [node^) xmltable
            )
    | [node) 'RECORD' & [node^) ty_def
    | [node) 'XMLQUERY' & [node^) xmlquery
    | [node) 'XMLTABLE' & [node^) xmltable
-> {
    addMargin(tuple.get("node"), -1 * indentSpaces);
}

r2_increment_left_margin_for_into_list:
      [node) into_list
    & [into) 'INTO'
    & node = into^
-> {
    var spaces = addMarginByName(tuple.get("node"), "INTO");
    addMargin(tuple.get("into"), -1 * spaces);
}

r2_increment_left_margin_for_select_list:
      [node) select_list
    & [node-1) 'SELECT'
-> {
    addMarginByName(tuple.get("node"), "SELECT");
}

r2_increment_left_margin_for_from:
      [node) from_clause
    & [from) 'FROM'
    & from^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "FROM");
    addMargin(tuple.get("from"), -1 * spaces);
}

r2_increment_left_margin_for_where:
      [node) where_clause
    & [where) 'WHERE'
    & where^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "WHERE");
    addMargin(tuple.get("where"), -1 * spaces);
}

r2_increment_left_margin_for_connect_by:
      [node) condition
    & [node-2) 'CONNECT'
    & [node-1) 'BY'
-> {
    var spaces = addMarginByName(tuple.get("node"), "CONNECT BY");
}

r2_increment_left_margin_for_start_with:
      [node) condition
    & [node-2) 'START'
    & [node-1) 'WITH'
-> {
    var spaces = addMarginByName(tuple.get("node"), "START WITH");
}

r2_increment_left_margin_for_group_by:
      [node) group_by_clause
    & [group) 'GROUP'
    & group^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "GROUP BY");
    addMargin(tuple.get("group"), -1 * spaces);
}

r2_increment_left_margin_for_having:
      [node) having_clause
    & [having) 'HAVING'
    & having^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "HAVING");
    addMargin(tuple.get("having"), -1 * spaces);
}

r2_increment_left_margin_for_order_by:
      [node) order_by_clause
    & [order) 'ORDER'
    & order^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "ORDER BY");
    addMargin(tuple.get("order"), -1 * spaces);
}

r2_increment_left_margin_for_update_set:
      [node) update_set_clause
    & [set) 'SET'
    & set^ = node
-> {
    var spaces = addMarginByName(tuple.get("node"), "SET");
    addMargin(tuple.get("set"), -1 * spaces);
}

r2_indent_nodes:
    [runOnce) sql_statements
-> {
    var it = leftMargin.keySet().iterator();
    while (it.hasNext()) {
        var key = it.next();
        var margin = leftMargin.get(key);
        var value = newlinePositions.get(key);
        var spaces = value.length()-value.lastIndexOf("\n")-1; // 0 = first column
        var comma = 0;
        var spacesAfterComma = 0;
        if (key < target.getSrc().size()) {
            if (target.getSrc().get(key).content == ",") {
                comma = 1;
                if (spaceAfterCommas) {
                   comma += 1;
                }
            }
        }
        if (useFullLeftMargin(key)) {
            struct.putNewline(key, value.substr(0, value.lastIndexOf("\n")+1) + getSpaces(margin-comma));
            logger.fine(struct.getClass(), "r2_indent_nodes: set calculated margin of " + (margin-comma) + " spaces at " + key);
        } else {
            if (margin-spaces-comma > 0) {
                for (var i=0; i<margin-spaces-comma; i++) {
                    value+=" ";
                }
                struct.putNewline(key, value);
                logger.fine(struct.getClass(), "r2_indent_nodes: add " + (margin-spaces-comma) + " spaces at " + key);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- R7: SQL keywords are right aligned within a SQL command.
-- --------------------------------------------------------------------------------------------------------------------

r7_select:
      ([parent) select | [parent) subquery | [parent) query_block)
    & (
          [keyword) 'DISTINCT'
        | [keyword) 'UNIQUE'
        | [keyword) 'ALL'
        | [keyword) 'BULK'
        | [keyword) 'INTO'
        | [keyword) 'FROM'
        | [keyword) 'JOIN'
        | [keyword) 'ON'
        | [keyword) 'FULL'
        | [keyword) 'LEFT'
        | [keyword) 'RIGHT'
        | [keyword) 'CROSS'
        | [keyword) 'OUTER'
        | [keyword) 'NATURAL'
        | [keyword) 'WHERE'
        | [keyword) 'CONNECT'
        | [keyword) 'START'
        | [keyword) 'GROUP'
        | [keyword) 'HAVING'
        | [keyword) 'ORDER'
      )
    & parent < keyword
;

r7_insert:
      [parent) insert
    & (
          [keyword) 'ALL'
        | [keyword) 'FIRST'
        | [keyword) 'WHEN'
        | [keyword) 'THEN'
        | [keyword) 'ELSE'
        | [keyword) 'INTO'
        | [keyword) 'VALUES'
        | [keyword) 'RETURN'
        | [keyword) 'RETURNING'
        | [keyword) 'LOG'
        | [keyword) 'REJECT'
        | [keyword) 'SELECT' & ![keyword^^-1) '('
      )
    & parent < keyword
;

r7_update:
      [parent) update
    & (
          [keyword) 'SET'
        | [keyword) 'WHERE'
        | [keyword) 'RETURNING'
        | [keyword) 'INTO'
      )
    & parent < keyword
;

r7_delete:
      [parent) delete
    & (
          [keyword) 'FROM'
        | [keyword) 'WHERE'
        | [keyword) 'RETURNING'
        | [keyword) 'INTO'
      )
    & parent < keyword
;

r7_right_align_keywords:
      r7_select
    | r7_insert
    | r7_update
    | r7_delete
-> {
    var keyword = tuple.get("keyword");
    var parent = tuple.get("parent");
    var parentIndent = System.lineSeparator() + getSpaces(getColumn(parent.from));
    var parentLength = target.getSrc().get(parent.from).content.length();
    if (target.getSrc().get(parent.from).content.toLowerCase() == "with") {
        parentLength = 6;
    }
    if (getIndent(keyword.from).contains("\n")) {
        if (alignRight) {
            var content = target.getSrc().get(keyword.from).content;
            var missingSpaces = parentLength - target.getSrc().get(keyword.from).content.length();
            var keywordIndent = parentIndent + getSpaces(missingSpaces);
            struct.putNewline(keyword.from, keywordIndent);
            logger.fine(struct.getClass(), "r7_right_align_keywords: align <" + content + "> at " + keyword.from);
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- O4: Alignment: Assignment Operator :=. Options: true; false. (alignAssignments).
-- --------------------------------------------------------------------------------------------------------------------

o4_declarations:
    [runOnce) sql_statements
-> {
    var assignments = new HashMap();
}

o4_body:
      ([scope) if_stmt | [scope) case_stmt | [scope) seq_of_stmts)
    & [node) ':'
    & [node+1) '='
    & scope < node
;

o4_declare_section:
      [scope) decl_list
    & [node) default_expr_opt
    & scope < node
;

o4_function:
      [scope) fml_part
    & [node) default_expr_opt
    & scope < node
;

o4_find_assignments:
      o4_body
    | o4_declare_section
    | o4_function
-> {
    if (alignAssignments) {
        var scope = tuple.get("scope");
        if (containsLineBreak(scope)) {
            addTupleToMap(tuple, "scope", assignments);
        }
    }
}

o4_align_assignments:
    [runOnce) sql_statements
-> {
    align(assignments, "node", "o4_align_assignments");
}

-- --------------------------------------------------------------------------------------------------------------------
-- O5: Alignment: Column and Table aliases. Options: true; false. (alignTabColAliases).
-- --------------------------------------------------------------------------------------------------------------------

o5_declarations:
    [runOnce) sql_statements
-> {
    var selectTermEndsOnNewline = function(node) {
        if (getIndent(node.to).contains("\n")) {
            return true;
        } else {
            var content = target.getSrc().get(node.to).content;
            if (content == ",") {
                if (getIndent(node.to+1).contains("\n")) {
                    return true;
                }
            }
        }
        return false;
    }

    var tableReferenceOnNewline = function (node) {
        var n = target.getRoot().leafAtPos(node.from - 1);;
        do {
            n = target.getRoot().leafAtPos(n.from - 1);
            if (getIndent(n.from).contains("\n")) {
                return true;
            }
        } while (!n.contains("'FROM'") && !n.contains("query_table_expression"))
        return false;
    }

    var aliases = new HashMap();
}

o5_column_alias:
      [scope) select_clause
    & [node) as_alias
    & scope < node
-> {
    if (alignTabColAliases) {
        var node = tuple.get("node");
        if (selectTermEndsOnNewline(node)) {
            addTupleToMap(tuple, "scope", aliases);
        }
    }
}

o5_table_alias:
      [scope) from_clause
    & [node) identifier
    & [node-1) query_table_expression
    & scope < node
-> {
    if (alignTabColAliases) {
        var node = tuple.get("node");
        if (tableReferenceOnNewline(node)) {
            addTupleToMap(tuple, "scope", aliases);
        }
    }
}

o5_align_aliases:
    [runOnce) sql_statements
-> {
    align(aliases, "node", "o5_align_aliases");
}

-- --------------------------------------------------------------------------------------------------------------------
-- R6: Call parameters aligned, operators aligned, values aligned.
-- --------------------------------------------------------------------------------------------------------------------

r6_align_assoc_args:
      [parent) paren_expr_list
    & [node+1) assoc_arg
    & parent < node+1
    & [parent^) function_call
-> {
    var parent = tuple.get("parent");
    if (containsLineBreak(parent)) {
        // comma or open parenthesis
        var node = tuple.get("node");
        var nodeContent = target.getSrc().get(node.from).content;
        // assoc arg
        var assocArg = tuple.get("node+1");
        var indent = getIndent(assocArg.from);
        var grandParent = tuple.get("parent^");
        var grandParentCol = getColumn(grandParent.from);
        if (struct.breaksAfterComma() || nodeContent == '(') {
            struct.putNewline(node.from, "");
            struct.putNewline(assocArg.from, System.lineSeparator() + getSpaces(grandParentCol + indentSpaces));
        } else {
            if (spaceAfterCommas) {
                struct.putNewline(node.from, System.lineSeparator() + getSpaces(grandParentCol + indentSpaces - 2));
                struct.putNewline(assocArg.from, " ");
            } else {
                struct.putNewline(node.from, System.lineSeparator() + getSpaces(grandParentCol + indentSpaces - 1));
                struct.putNewline(assocArg.from, "");
            }
        }
        // closing parenthesis
        struct.putNewline(new Integer(parent.to-1), System.lineSeparator() + getSpaces(grandParentCol));
        logger.fine(struct.getClass(), "r6_align_assoc_args: at " + assocArg.from);
    }
}

r6_declarations:
    [runOnce) sql_statements
-> {
    var assocArgParents = new HashMap();
}

r6_find_assignment:
      [parent) paren_expr_list
    & [node^) assoc_arg
    & [node) '='
    & parent < node
-> {
    if (alignNamedArgs) {
        var parent = tuple.get("parent");
        if (containsLineBreak(parent)) {
            addTupleToMap(tuple, "parent", assocArgParents);
        }
    }
}

r6_align_assignments:
    [runOnce) sql_statements
-> {
    align(assocArgParents, "node", "r6_align_assignments");
}

r6_align_expr:
      [parent-2) '='
    & [parent-1) '>'
    & [parent) expr
    & [node) compound_expression[25,44)
    & parent < node
-> {
    var node = tuple.get("node");
    if (containsLineBreak(node)) {
        var parent = tuple.get("parent");
        var parentCol = getColumn(parent.from);
        struct.putNewline(node.from, System.lineSeparator() + getSpaces(parentCol));
        logger.fine(struct.getClass(), "r6_align_expr: at " + node.from);
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A9: Align xmltable columns.
-- --------------------------------------------------------------------------------------------------------------------

a9_declarations:
    [runOnce) sql_statements
-> {
    var xmlTableColumns = new HashMap();
}

a9_find_columns:
      [scope) XMLTABLE_options[19,37)
    & [node) XML_table_column
    & [comma) ','
    & scope < node
    & node = comma+1
-> {
    var scope = tuple.get("scope");
    addTupleToMap(tuple, "scope", xmlTableColumns);
}

a9_align_xmltable_columns:
    [runOnce) sql_statements
-> {
    var it = xmlTableColumns.keySet().iterator();
    while (it.hasNext()) {
        var scope = it.next();
        struct.putNewline(new Integer(scope.from+1), " ");
        var pos = getColumn(scope.from+1);
        var list = xmlTableColumns.get(scope);
        for (var i=0; i<list.length; i++) {
            if (struct.breaksBeforeComma()) {
                var comma = 1;
                if (spaceAfterCommas) {
                   comma += 1;
                }
                var commaNode = list.get(i).get("comma");
                struct.putNewline(commaNode.from, System.lineSeparator() + getSpaces(pos - comma));
                logger.fine(struct.getClass(), "a9_align_xmltable_columns: comma at " + commaNode.from);
            } else {
                var node = list.get(i).get("node");
                struct.putNewline(node.from, System.lineSeparator() + getSpaces(pos));
                logger.fine(struct.getClass(), "a9_align_xmltable_columns: column at " + node.from);
            }
        }
    }
}

-- --------------------------------------------------------------------------------------------------------------------
-- A4: Split long lines.
-- --------------------------------------------------------------------------------------------------------------------

-- This must run at the very end to override SQLDev's default behavior.
-- SQL Developer adds a line break after the token that exceeds max char line width.
-- This behaviour is not wanted, since the indentation is not added.
-- This piece of code addresses this issue. It adds a new line with the indentation of the current line.
-- No additional indentation is added to make this work for long argument lists as well
-- (indentation might not be reduced on subsequent formatter calls).
-- It's important to note that the lines may be a bit longer than the configured max char line width.
-- That's expected and matches the SQLDev logic. It ensures also that corner cases can be handled by
-- this code (e.g. string tokens > max char line width).
-- Due to this simple algorithm, it is expected that a subsequent formatter call will produce a different result.

a4_add_line_breaks_with_indent:
    [runOnce) sql_statements
-> {
    var pos = 0;
    var indent = System.lineSeparator(); /* handle first line */
    for (var key=0; key<target.getSrc().size(); key++) {
        if (pos > maxCharLineSize && target.getSrc().get(key).content.length() > 1 && !getIndent(key).contains("\n")) {
            struct.putNewline(key, indent);
            pos = indent.length() + target.getSrc().get(key).content.length();
            logger.fine(struct.getClass(), "a4_add_line_breaks_with_indent: at " + key);
        } else {
            var value = getIndent(key);
            if (value.contains("\n")) {
                pos = getNumCharsAfterNewLine(value);
                indent = System.lineSeparator() + getSpaces(pos);
            } else {
                pos += getNumCharsAfterNewLine(value);
            }
            pos += target.getSrc().get(key).content.length();
        }
    }
}
